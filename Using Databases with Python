# Using Databases with Python

So, welcome to our Databases course. 
This is the fourth course in the class and if you have taken all three, 
you have learned a bunch. 
There's a lot in this class. 
If you're two weeks into this class and you didn't take the prerequisite courses, 
and you're like what are these people talking about? 
Well, that's what those other courses are. 
Don't say, "oh why didn't you give me a basic intro to Python?" 
And the answer is we did that. 
That's what courses One, Two And Three were. 
You'll notice that in courses Three and Four, 
that we're going more slowly through the book. 
The material's more complex, 
the lectures take longer to develop. 
In this we're going to learn Object Training Programming, 
we're you're going to learn Structured Query Language, 
and we're going to do a little bit of Visualization. 
In a way, Structured Query Language is the the biggest part of this class. 
We're going to learn about Database design, 
and this is so that ultimately, 
if you need these Databases as part of a Python program, 
you're competent in Databases. 
So, this is more about Database than it is about Python. 
We're going to learn about, like I said, 
Database design, One-to-One relationships, 
Foreign keys, Joins, Select, Delete, Update. 
I love SQL, Structured Query Language. 
I think you probably will too. 
Most beginning students prefer SQL, in a way to Python. 
Because SQL is a fundamentally different pattern for writing software. 
In Python you have learned that you got to be very explicit. 
Like do this, then do that and keep track 
of this other thing and then check back in that other thing, 
and add a thing to this other thing, 
and then print these stuff out and sort them. 
You're like, do it and there's a bunch of 
really simple kind of things that you construct. 
Orders and patterns and loops, 
and that's what you're good at by now. 
In SQL you do it all in one one statement. 
You're like, do this where that happens, 
pull this other stuff and blah blah, blah, blah, blah, 
and then magically you get exactly what you want. 
You write single statement programs 
that are themselves internally interesting and complex. 
Like regular expressions. 
Regular expressions are not essential but SQL in lots of job situations is essential. 
So I think that you should look forward to learning SQL. 
It's a fun language. It's different, 
so get ready for that. 
Then what we do at the very end is, 
we do a little bit- bring it all together and do 
some analysis and visualization and scraping, 
which is really a preview for the Fifth or the Capstone, 
where we're just going to do analysis, visualization and scraping. 
So, welcome to course Four, I hope you enjoy it.
Help us learn more about you!
As part of getting to know you better, your backgrounds, your interest in this specific course and in digital education in general, we at the University of Michigan have crafted a survey that should only take a few minutes to complete. Our goal is to keep our communication with you focused on learning and staying in touch, but we believe that both this and an end-of-course survey are important to our mutual educational goals.

Using Databases with Python

So, welcome to our Databases course. 
This is the fourth course in the class and if you have taken all three, 
you have learned a bunch. 
There's a lot in this class. 
If you're two weeks into this class and you didn't take the prerequisite courses, 
and you're like what are these people talking about? 
Well, that's what those other courses are. 
Don't say, "oh why didn't you give me a basic intro to Python?" 
And the answer is we did that. 
That's what courses One, Two And Three were. 
You'll notice that in courses Three and Four, 
that we're going more slowly through the book. 
The material's more complex, 
the lectures take longer to develop. 
In this we're going to learn Object Training Programming, 
we're you're going to learn Structured Query Language, 
and we're going to do a little bit of Visualization. 
In a way, Structured Query Language is the the biggest part of this class. 
We're going to learn about Database design, 
and this is so that ultimately, 
if you need these Databases as part of a Python program, 
you're competent in Databases. 
So, this is more about Database than it is about Python. 
We're going to learn about, like I said, 
Database design, One-to-One relationships, 
Foreign keys, Joins, Select, Delete, Update. 
I love SQL, Structured Query Language. 
I think you probably will too. 
Most beginning students prefer SQL, in a way to Python. 
Because SQL is a fundamentally different pattern for writing software. 
In Python you have learned that you got to be very explicit. 
Like do this, then do that and keep track 
of this other thing and then check back in that other thing, 
and add a thing to this other thing, 
and then print these stuff out and sort them. 
You're like, do it and there's a bunch of 
really simple kind of things that you construct. 
Orders and patterns and loops, 
and that's what you're good at by now. 
In SQL you do it all in one one statement. 
You're like, do this where that happens, 
pull this other stuff and blah blah, blah, blah, blah, 
and then magically you get exactly what you want. 
You write single statement programs 
that are themselves internally interesting and complex. 
Like regular expressions. 
Regular expressions are not essential but SQL in lots of job situations is essential. 
So I think that you should look forward to learning SQL. 
It's a fun language. It's different, 
so get ready for that. 
Then what we do at the very end is, 
we do a little bit- bring it all together and do 
some analysis and visualization and scraping, 
which is really a preview for the Fifth or the Capstone, 
where we're just going to do analysis, visualization and scraping. 
So, welcome to course Four, I hope you enjoy it.
Help us learn more about you!
As part of getting to know you better, your backgrounds, your interest in this specific course and in digital education in general, we at the University of Michigan have crafted a survey that should only take a few minutes to complete. Our goal is to keep our communication with you focused on learning and staying in touch, but we believe that both this and an end-of-course survey are important to our mutual educational goals.

## Coming from Python 2 - Encoding Data in Python 3
If you took the earlier courses in Python 2, you need to gain a brief understanding of how to handle networked data with character sets other than the "Latin" character sets. When data is moved between systems, characters like (次 - Tsugi) or (코스 - Koseu) must be properly encoded as they are passed between different systems as Unicode data. The most common Unicode encoding is UTF-8.
We have included lecture 12.3 from the previous course to give you a brief review of data encoding in Python 3 to get you quickly up to speed.
So we started this entire course printing hello world and I just said quote, 
hello world, quote and out comes hello world. 
And it'd be nice if that was super simple.
Play video starting at ::22 and follow transcript0:22
And you know in 1970, it was simple because 
there was pretty much one character set. 
Even in 1970, when I started we didn't even have lowercase characters, 
we just had uppercase characters. 
And I'll tell you we were happy when we just had uppercase characters. 
You kids these days with your lowercase characters and numbers and 
slashes and stuff.
Play video starting at ::44 and follow transcript0:44
So the problem that computers have is they have to come up with a way, 
I mean, computers don't understand letters, actually. 
What computers understand is numbers, and so 
we had to come up with a mapping between letters and numbers. 
And so we came up with a mapping, and there's been many mappings historically. 
The one that sort of is the most common mapping of 
the 1980s is this mapping called ASCII. 
The American Standard Code for Information Interchange. 
And it says basically, this number equals this letter. 
So for example, the number for 
hello world, that for capital H the number is 72. 
Somebody just decided that the capital H was going to be 72. 
Lowercase e, the number is 101. 
And newline is 10. 
So if you were really and truly going to look at 
what was going on inside the computer, it's storing these as numbers. 
But the problem is, is there are 128 of these. 
Which means that you can't put every character into a 0 through 128. 
And so, 
in the early days we just kind of dealt with whatever characters were possible. 
Like I said, when I started you could only do uppercase. 
You couldn't even do lowercase, and so 
there is this function, as long as you're dealing with simple values. 
That you can say hey, what is the actual value for the letter H. 
And it's called ord, which stands for ordinal. 
What's the ordinal? 
What is the number corresponding to H, and that's 72. 
What's the number corresponding to lowercase e? It's 101. 
And what's the number corresponding to newline? And that is a 10. 
Remember, newline is a single character.
Play video starting at :2:32 and follow transcript2:32
This also kind of explains why the lowercase letters are all greater 
than the uppercase letters, because they're ordinal for ASCII. 
Now, there's so many character sets but just for 
the default old school 128 characters that we could represent with ASCII, 
the uppercase letters had a lower ordinal than lowercase letters. 
So, Hi is less than
Play video starting at :3: and follow transcript3:00
zzz all lowercase, and that's because all lowercase letters are less. 
I mean all uppercase letters are less than all lowercase letters. 
Actually this can be AAA, that's what I should have said there, okay? 
So don't worry about that. 
Just know that they are all numbers. 
And in the early days, life was simple. 
We would store every character in a byte of memory, 
otherwise known as eight bits of memory. 
It's the same thing when you say I have a many gigabyte USB stick, that's 
a 16 gigabyte USB stick, that means there are 16 billion bytes of memory on there. 
Which means we could put 16 million characters on here in the old days, okay? 
So the problem is in the old days we just had so 
few characters that we could put one character in a byte. 
And so the ord function tells us the numeric value of a simple ASCII character. 
And so like I said, if you take a look at this 
the e is 101 and the H, capital H is 72. 
And then the newline which is here at the line feed which is 10. 
Now we could represent these in hexadecimal which is base 16 or 
octal which is base 8. 
Or actual binary which is what's really going on which is nothing but 0's and 1's. 
But this is the binary for 10. 
0001010, and so these three are just alternate versions of these numbers. 
The numbers go up to 127, if you look at the binary, you can see in this, 
this is actually seven bits of binary. 
You could see that's all 1's, so it starts at all 0's goes to all 1's. 
And so it's like 0's and 1's are what the computers always do. 
And if you go all the way back to the hardware the little wires and 
stuff, the wires are character are taking 0's and 1's. 
So this is what we did and in the 60s and 
70s we just said whatever we're capable of squeezing in we're just totally happy. 
We're not going to have anything tricky and like I said 
halfway early in my undergraduate career I started to see lowercase letters. 
I'm like that's really beautiful, lowercase letters. 
Now, the real world is nothing like this. 
There are all kinds of characters. 
And they had to come up with a scheme by which we could map these characters. 
And for a while there were a whole bunch of incompatible ways to represent 
characters other than these ASCII, also known as Latin character sets. 
Also known as Arabic character sets. 
These other character sets just completely invented their own way of representing. 
And so you had these situations where Japanese computers pretty much couldn't 
talk to American computers or European computers at all. 
I mean, the Japanese computers just had their own way of representing characters. 
And the American computers had their own way of representing characters and 
they just couldn't talk. 
But they invented this thing called Unicode. 
And so Unicode is this universal code for hundreds of 
millions of different characters and hundreds of different character sets. 
So that instead of saying sorry, 
you don't fit with your language from some South Sea island, 
it's okay. We've got space in Unicode for that. 
And so Unicode has lots and lots of characters, not 128. 
Lots and lots of characters.
Play video starting at :6:13 and follow transcript6:13
And so there was a time, like I said in the 70s and 
the 80s where everyone had something different. 
And even like in the early 2000s, what happened was that as the Internet 
came out it became an important issue to have a way to exchange data. 
And so we kind of had to say oh, well, it's not sufficient for 
Japanese computers to talk to Japanese computers 
and American computers to talk to American computers, we want Japanese and 
American computers to exchange data. 
So they built these character sets, and so there is Unicode, 
which is sort of this abstraction of all the different possible characters. 
And there are different ways of representing them inside of computers. 
And so there's a couple of simple things that you might think are good ideas that 
turn out to be not such good ideas, although they're used. 
So the first thing we did is these UTF-16, UTF-32 and 
UTF-8 are basically ways of representing a larger set of characters. 
Now the gigantic one is 32 bits, which is 4 bytes. 
It's 4 times as much data for a single character. 
And so that's quite a lot of data, so 
you're dividing the number of characters by four. 
So if this is 16 GB, it can only handle 4 billion characters, or something. 
Divided by four, right, four bytes per character. 
And so that's not so efficient. 
And then, there's a compromise like I have two bytes, 
but then you'd have to pick. 
This can do all the characters. 
This can do sort of lots of character sets. 
But turns out that even though you might instinctively think that UTF-32 
is better than UTF-16 and UTF-8 is the worst? 
It turns out that UTF-8 is the best. 
So UTF-8 basically says, it's either going to be one, two, three or 
four characters and there's little marks that tell it when to go from one to four. 
The nice thing about it is that UTF overlaps with ASCII, right? 
And so if the only characters you're putting in are the original ASCII or 
Latin I character set, then UTF-8 and ASCII are literally the same thing. 
And then use a special character that's not part of ASCII to indicate flipping 
from one-byte characters to two-byte characters or 
three-byte characters or four-byte. 
So it's a variable length. 
And so you can automatically detect, you can just be reading through a string and 
say, whoa I just saw this weird marker character. 
I must be in UTF-8. 
And then if I'm in UTF-8 then I can sort of expand this and find, 
represent all those character sets and all those characters in those character sets.
Play video starting at :8:43 and follow transcript8:43
And so what happened was is they went through all these things and 
as you can see from this graph, the graph doesn't really say much other than 
the fact that UTF-8 is awesome and getting awesomer. 
And every other way of representing data is becoming less awesome, right? 
And this is 2012, so that's a long time ago. 
So this was like, UTF-8 rocks, and 
that's really because, as soon as these ideas came out, it was really clear 
that UTF-8 is the best practice for encoding data moving between systems. 
And that's why we're talking about this right now. 
Finally, with this network we're doing sockets we're moving data between systems. 
So your American computer might be talking to a computer in Japan and 
you've got to know what character set's coming out, right? 
And you might be getting Japanese characters even though everything I've 
shown you is non-Japanese characters or Asian characters or whatever, right? 
So UTF-8 turns out to be the best practice 
if you're moving a file between two systems. 
Or if you're moving network data between two systems we recommend, 
the world recommends UTF-8, okay? 
So if you think about your computer, inside your computer, 
the strings that are inside, your Python like x equals hello world, 
we don't really care what their syntax is. 
And if there's a file usually the Python running on the computer and 
the file had the same character set. They might be UTF-8 inside Python. 
It might be UTF-8 inside, but we don't care. 
You open a file, and 
that's why we didn't have to talk about this when we were opening files. 
Even though you might some day encounter a file that's different than 
your normal character set, it's rare, okay? 
So files are inside the computer. 
Strings are inside the computer. 
But network connections are not inside the computer and when we get to databases 
we're going to see they're not inside of the computer either. 
And so this is also something that's changed from Python 2 to Python 3. 
It was actually a big deal, a big thing. 
And most people think it's great, I actually think it's great. 
Some people are grumpy about it, 
but I think those people just are people that fear change. 
So, there were two kinds of strings in Python, 
there were a normal old string and a Unicode string. 
And so you could see that Python 2 would be able to make a string constant, and 
that's type string, and it would it make a Unicode by prefixing u before the quote. 
And that's a separate kind of thing, and then you had to convert back and 
forth, between Unicode and strings. 
What we've done in Python 3 is this is a regular string and 
this is Unicode string, but you'll notice they're both strings. 
So it means that inside of the world of Python, if we're pulling stuff in, 
you might have to convert it. 
But inside Python everything is Unicode. 
You don't have to worry about it, 
every string is kind of the same whether it has Asian characters or 
Latin characters or Spanish characters or French characters, it's just fine. 
So this simplifies this, 
but then there's certain things that we're going to have to be responsible for.
Play video starting at :11:29 and follow transcript11:29
So the one kind of string that we sort of haven't used yet 
but becomes important. and it's present in both Python 2 and Python 3. 
Remember how I said in the old days a character and a byte were the same thing? 
And so there's always been a thing like a byte string and 
they do this by prefixing the b. 
And that says, this is a string of bytes that mean this character. And 
if you look at the byte string in Python 2, 
and then you look at a regular string in Python 2, they're both type string. 
The bytes are the same as string, and the Unicode is different. 
So these two are the same in Python 2, and these two are different in Python 2.
Play video starting at :12:12 and follow transcript12:12
Not doing a very good picture of that. 
So the byte string and the regular string are the same. 
And the regular string and the Unicode string are different. 
So what happened is in Python 3 the regular string and 
the Unicode string are the same.
Play video starting at :12:31 and follow transcript12:31
And now the byte string and the regular string are different, okay? 
So bytes turns out to be raw, 
unencoded, that might be UTF-8, might be UTF-16, it might be ASCII. 
We don't know what it is, we don't know what its encoding is. 
So it turns out that this is the thing we have to manage when we're dealing with 
data from the outside. 
So in Python 3 all the strings internally are Unicode. 
Not UTF-8, not UTF-16, not UTF-32, 
and if you just open a file, it pretty much usually works. 
If you talk to a network now, we have to understand. 
Now the key thing is we have to decode this stuff. 
We have to realize what is the character set of the stuff we're pulling in. 
Now the beauty is, is because 99% or maybe 100% of the stuff you're 
going to run across just uses UTF-8, it turns out to be relatively simple.
Play video starting at :13:28 and follow transcript13:28
So, there's this little decode operation, so if you look at this code right here. 
When we talk to an external resource we get a byte array back like the socket 
gives us an array of bytes which are characters. 
But they need to be decoded so we know, if it could be UTF-8, UTF-16 or ASCII. 
So there is this function that's part of byte arrays, so 
data.decode says figure this thing out. 
And the nice thing is, is you can tell it what character set it is but 
by default it assumes UTF-8 or ASCII dynamically. 
Because ASCII and UTF-8 are upwards compatible with one another. 
So if it's like old data, you're probably getting ASCII, if it's newer data, 
you're probably getting UTF-8. 
And literally, it's a law of diminishing returns, 
it's very rare that you get anything other than those two, 
so you almost never have to tell it what it is, right? 
So you just say decode it, look at it. 
It might be ASCII, might be a UTF-8, but 
whatever it is by the time it's done with that it's a string. 
It's all Unicode inside of this. And so this is bytes.
Play video starting at :14:32 and follow transcript14:32
And this is Unicode.
Play video starting at :14:36 and follow transcript14:36
So decode goes from bytes to Unicode.
Play video starting at :14:42 and follow transcript14:42
And you also can see, when we're looking at the sending of the data, 
we're going to turn it into bytes. 
So encode takes this string and makes it into bytes. 
So this is going to be bytes that are properly encoded in UTF-8. 
Again, you could have put a thing here, UTF-8, but it just assumes UTF-8. 
And this is all ASCII, so it actually doesn't do anything so, but that's okay. 
And then we're sending the bytes out the command. 
So we have to send the stuff out, then we receive it, we decode it, 
when we send it we encode it. 
Out in this real world is where the UTF-8 is. 
Here we just have Unicode.
Play video starting at :15:21 and follow transcript15:21
And so, before we do the send and before we receive, we have to encode and 
decode this stuff so that it works out and it works out correctly. 
And so you can look at the documentation for both the encode and the decode. 
Decode is a method in the bytes class. 
And it says, you can see that the encoding we're telling it, 
you can say it's not UTF-8, ASCII and UTF-8 are the same thing. 
The default is UTF-8, which is probably all you're ever going to use, 
and the same thing is true, strings can be encoded using UTF-8 into a byte array and 
then we send that byte array out to the outside world.
Play video starting at :15:58 and follow transcript15:58
And it sounds more complex than it is. 
So after all that, think of it this way.
Play video starting at :16:8 and follow transcript16:08
On the way out, we have a internal string. 
Before we send it, we have to encode it, and then we send it. 
Getting stuff back, we receive it, it comes back as bytes. 
We happen to know it's UTF-8 or we're letting it automatically detect UTF-8 and 
decode it and now we have a string. 
And now internally inside of Python we can write files, 
we can do all kinds of stuff in and out of stuff and it sort of works all together. 
It's just that this is UTF-8 ?? 
This is the outside world. 
And so you kind of have to look at your program and 
say okay, when am I talking to the outside world? 
Well in this case, it's when I'm talking to a socket, right? 
I'm talking to a socket, so I have to know enough to encode and 
decode as I go in and out of the socket. 
So it looks kind of weird when you all of a sudden start seeing these 
encodes and decodes. 
But they actually make sense. 
There's sort of like this barrier between this outside world and our inside world. 
So that inside our data is all completely consistent and we can mix strings 
from various sources without regard to the character set of those strings. 
So now what we're going to do is we're going to rewrite that program. 
It's a short program, but we're going to make it even shorter.
Notice for Auditing Learners: Assignment Submission
Please note: only verified learners can submit assignments. If you are auditing this course, you will be able to go through the quizzes or assignments, but you will not be able to submit your assignment for a grade. If you wish to have your assignments graded and receive a course certificate, we encourage you to upgrade to the Certified Learner track for this course. Coursera has provided information about purchasing a certificate, and you can also get help from the Coursera Help Center.
Hello and welcome to my video that shows how to get started and 
install Python on Microsoft Windows. 
Okay, so it's not too hard. 
We're going to both install Python 3 and we're going to install text editor. 
And so I'm just going to go into Google and I'm going to say, install Python 3. 
And my top link is Downloading Python.
Play video starting at ::27 and follow transcript0:27
And there is my link for downloading Python 3.5.2. 
This version of my class uses Python 3. 
I have an earlier class that you may have seen that uses Python 2. 
But in this class, we're going to do this. 
Now it might take you a while to download this. 
I've actually already downloaded it. 
Now the other thing we need is a programmer text editor. 
And you can really use any programmer text editor. 
We've used Notepad+ in the past. 
We've used JEdit in the past. 
I liked Atom.io. 
T-O-M. 
.Io mostly because it works the same on Windows and Mac and Linux. 
But you can really use any text header that you like, 
just don't use Word or TextEdit that comes with the operating system. 
You need a programming editor that doesn't mess with weird characters or 
weird lines or strange formats >> You must have a real programmer editor. 
And so I'm going to down, I've already downloaded this as well.
Play video starting at :1:31 and follow transcript1:31
And so I won't waste the time waiting to download it but let's go ahead and 
do the installation. 
So these things ended up in my Downloads file, 
so I'll go to Downloads. 
And I'll start installing Python 3.5.2. 
Now it's going to ask me some things. 
Add Python 3.5 to the path. 
Yeah, that's a good idea. 
Install the launcher for all users. 
I'm going to add that. 
Maybe you will, maybe you won't do that. 
It's going to tell me where it's going to install it.
Play video starting at :2:14 and follow transcript2:14
Install Now. 
[SOUND] Of course, it's going to ask me for permission to do these things. 
And now it's running through the installation.
Play video starting at :2:26 and follow transcript2:26
Okay, so there we go. 
You could maybe click on this online tutorial and documentation, but 
we're just going to close this.
Play video starting at :2:38 and follow transcript2:38
And I'm going to start and run the Windows command line. 
Now, you may have all kinds of fancy ways to run Python but 
I like running the command line. 
C-O-M-M-A-N-D. I like running the command line because 
after a while it's important to know 
what folder things are being run in. 
and so here's this command line and I should be able to type Python here. 
And so now I'm in Python 3.2 and this is the chevron prompt. 
Here is the Python interpreter where it's asking for Python commands and 
I can say print.
Play video starting at :3:23 and follow transcript3:23
Hello world, of course this is what we tend to print all the time.
Play video starting at :3:28 and follow transcript3:28
I can make a mistake, I can say.
Play video starting at :3:38 and follow transcript3:38
Right, and it'll complain to me. 
Now, to get out of this, I can either type Ctrl+Z or quit. 
In this case, I'm going to type Ctrl+Z, and I'm back to the prompt. 
A couple of things, I can do a dir to see what folders and 
files I have, and that is like my desktop. 
And then the cd command tells me where I'm at in the folder, 
that means I'm in the user's directory doctor chart, okay? 
So I have now installed Python. 
I ran the Python interpreter to verify it. 
I said, print Hello World. 
Okay, and so now what I'm going to do is I'm going to actually install Atom. 
And I already had this downloaded, so let's go ahead and 
install Atom on my computer.
Play video starting at :4:37 and follow transcript4:37
Okay, so Atom is now installed and it's kind of telling us what to do. 
I'm going to actually just close all these windows, close this window, 
close everything, and I'm going to create a file. 
I'm going to say print, in this case, 
let's see if I can make this bigger, 
I can make it bigger, so I'm going to type print, 
hello from a file, okay, and I'm going to save this. 
I'm going to say File, Save as, 
and what I'm going to do is I'm going to go to my desktop,
Play video starting at :5:23 and follow transcript5:23
And I am going to make a folder on the desktop. 
I'm going to call this folder py4e. 
So I now have a folder on the desktop. 
Move this here and move this here. 
Oops. And I'm going to go into py4e and 
then I'm going to name this file first.py.
Play video starting at :5:49 and follow transcript5:49
And you'll notice that when I save this, 
it's syntax highlighted it. 
That's one of the nice things about a programmer editor. 
Okay? And so it says, it's got a suffix of .py. 
So therefore it knows that it's supposed to look pretty with Python and 
make this one color, make this another color. 
The other thing that you'll notice is that I now have a folder called py4e. 
And if I'm in this command line, let me just start that up again. 
I'll show you how to start the command line again.
Play video starting at :6:24 and follow transcript6:24
Command, now if I do a dir, I see the folders that I'm in. 
And one of the folders that you can see here is the desktop folder. 
So I'm going to say cd.desktop, 
and then I'm going to type the dir command to see what folders are in the desktop. 
These folders are the same as these folders. 
This things are kind of virtual folders. 
Py4e is py4e. 

Now I can type cd, which stands for change directory, py4e and I can do a dir and 
now you see first.py and that's the same as if I'm diving into this folder. 
Here's this file, first.py, Windows hides the suffix, which is somewhat annoying and 
frustrating, but that suffix is there, that file is there. 
And so for me, one of the things you gotta figure out in Windows is how to make sure 
you are in the same folder, Users\drchu\Desktop\py4e, 
and that's the name of this file, and here as well. 
And now I'm going to run this program. 
I'm going to type python first.py. 
And you see that it ran the Python code. 
Okay? 
Another way you can do this is you could type first.py. 
And that's because this file association has happened in Windows. 
This doesn't work in Macintosh. 
This only works in Windows, that all files with .py are expected to be Python. 
And it knows the Python interpreter where to run it. 
Okay, and so I've got Python 3.0 installed and that gets me started and so 
I hope that this little introduction about getting things started and 
writing your first Python program has been helpful to you.


Hello, and I would like to talk to you about how 
to use the snipping tool to do a screen capture. 
There are other ways to do this, but the easiest way is the built in screen tool, 
and I'm doing this on Windows 8. 
The snipping tool exists on earlier versions Windows as well, and so 
the gestures and the UI might look a little different but it is about the same. 
You find the snipping tool. 
So, I'm going to hit the Windows icon, and 
I'm going to type S-N, and it brings up the Snipping Tool. 
And so, here I go. 
And, it's giving me this option to say Snipping Tool. 
And, I like to say, I'm going to do a new Window Snip. 
An now, it's kind of graying out the screen and 
following me around with this little red line. 
And I clicked on this and it has made a copy of that window. 
Now this Snipping Tool is just Snipping Tool, that window still exists. 
This is now, didn't want to do that. 
This is now just a drawing tool that's. 
So, and so here you are. 
We could save this, but the other thing you can do and 
this is in the more recent snipping tools is you can make changes. 
So let's say for example that you didn't want to show your name, and 
your name was in this path. 
And so I will just go and 
scribble my name out, like with this little scribbling tool. 
Pretty sweet? 
So, I scribbled my name out. 
I just happened to have my name in it, so I just didn't want to put it in. 
So now, I'm going to do File > Save as. 
And, of course, find somewhere, I'm going to put this on my Desktop, 
and I'm going to call it notepad.png. 
Now, you don't have to put a suffix of .png or .jpg. 
But it's good if you're moving files between systems. 
So, put the suffixes on. 
Windows would know this was a PNG file, but .png is a way to nicely tell other 
systems, when you're moving it around, that it's a PNG file. 
Or, if you send it as an email, or whatever. 
So, I save it, I'm saving it on my desktop, and there we go. 
So it's hiding the .png, but I can look to make sure the png is really there. 
And so there it is, it's a .png. 
And so there's a file and away we go, okay? 
So there's the snipping tool. 
If I close this window and I click on Notepad, 
[SOUND] you will see that it's got the little scribbling thing. 
Thank you for that, okay? 
So, there you go. 
That's how to do a real simple snipping tool.

In this video, 
we're going to actually download and install Python 3 from 
python.org on a Macintosh if your Mackintosh, 
for years, has wonderfully come with Python 2. 
So, if I type Python minus minus version,
Play video starting at ::25 and follow transcript0:25
I type that, I see that I'm got Python 2.0. 
What we want to do is in addition installed Python 3. 
One of these days, Macintosh might upgrade their distributed version of Python 3, 
but there's so many things inside Mac that depend on Python 2. 
I'm going to expect that it will always be named Python 3, 
which is what we're going to call it in a second. 
So, here I am at the python.org/downloads, 
and I'm going to download Python 3, you click here, 
and I'm actually got it sitting here in Downloads already because I always do that. 
So, I'm going to install this. 
There is the installer, 
we'll say Continue, Continue, 
Continue. Of course, I agree. 
I read all that really fast, 
and now I'm going to install it.
Play video starting at :1:21 and follow transcript1:21
Okay. So now, that means if I run a terminal, 
so this of course, 
is start run terminal. 
So, Python 2 is still there, 
but Python 3 is also now involved there. 
So, we should have Python 3 installed. 
So, we install Python 3.6, and so there we go. 
That's all it takes to install Python 3 on a Macintosh. 
So, let's write our first little Python program. 
I'm going to, I like Atom. 
So, I've got this Atom Editor, it's atom.io. 
Right here, atom.io, download and install the Atom Editor. 
I like it because Atom works the same on both Windows, 
Mac, and Linux, and it has syntax highlighting, 
so I really like things like that. 
So, I'm going to make myself a simple Python program. 
Hello world, like we always do. 
Now, you'll notice that it's not syntax highlighting yet, 
but I'm going to do a File, 
Save As, and I'm going to go into my desktop, 
and I want to make a folder called py4e. 
I'm just calling this call as hello.py. 
Oh, crud got to rename it. 
Rename it, and put two dots hello.py, there we are. 
So, now I'm here, 
and I'm in my home folder, 
I can go on my desktop, 
and I can go into that new folder I made Python for everybody, 
and I can see the files. 
Now, there are ways to run this. 
I really want you to learn the terminal so that you really know what you're doing. 
So, here we are, we're in the folder that has the Python, 
and then all we do to run it is we say, 
"python3 hello.py", and there we go. 
Of course, this is Python 3, 
because I'm using parentheses there instead of double quotes. 
But Python two is still there, and of course, 
if you just run python hello.py, 
it'll be a syntax error or not. 
Must be they added something. 
Yeah. Because Python is still version two, 
but apparently, they allowed print in the latest version of Python 2. 
So, away we go. 
Okay? So again, thanks for watching. 
I hope this was helpful to you to get Python 3 installed on your Macintosh.
Hello, and welcome to the podcast on taking screenshots on the Macintosh. 
Nicely, the Macintosh has a very simple tool built in. 
We go into Macintosh hard drives, we go to Applications, 
and then we search down for Preview. 
Preview, right here. 
So Preview. And I'll close this now. 
So we've got Preview. 
Preview's the application that was originally built to view PDFs on 
the Macintosh. 
But it also has a whole series of screen capture capabilities. 
And I like to keep Preview in my dock all the time. 
So I come down here on the Preview icon. 
And it's already in my dock. 
If I said remove from dock, and then I would say keep in dock. 
It was already there, as soon as I start Preview, I always keep it in the dock. 
But all the things I need to use all the time in the dock. 
And so, let's take a screenshot. 
I'll just sort of start a jEdit program. 
And I'll say take me as a screenshot. 
Whatever. 
Doesn't matter. 
Just this is the window that I want to take a picture of. 
This window right here. 
So I go to Preview, and I say File. 
This is in the most logical place. 
Begin to grab a rectangular selection in which you'll be allowed 
to draw with your cursor or a window or the whole screen when timed. 
90% of the time, what you really want to do is take a window. 
You can say grab window, it tells you you can grab, go over different windows, 
I can click here, I can click there, I can click there. 
And I just want to capture this windows. 
So click, I go like that. 
Now, here is a little weird. 
This is now on image, okay? 
And so, you can't click on this stuff, okay? 
That's that. 
So what you need to do. 
I'm going to close the original real window now. 
This is my J Edit, I'm going to Cmd+Q get rid of J Edit. 
And I do not want to save that file. 
So now, I'm in Preview. 
See, I'm in Preview here. 
And so, I've got this as an image. 
Now, the one thing it does is it always saves it to your desktop. 
So which gets to be sort of painful after a while. 
It gives them these long names called Snapshot that has the date, and 
stores it in this format capped Tip.
Play video starting at :2:22 and follow transcript2:22
So I prefer to switch it to a non-Apple format. 
So I want to do a Save As. 
And I'm going to save this as a JPEG. 
And I give it a better name called first image. 
And it'll be a JPEG, and I'm going to store it right on my desktop. 
So now, here we have first image, okay? 
And I can click on that and take a look at it. 
I'll close this. 
Click on it. 
Interestingly, it just comes back up in preview. 
So that's pretty much it. 
This would be the file you would upload if your job was to do this. 
I'll show you a couple other tricks I like to make my images a little bit better. 
Preview has a simple tool for cropping. 
And the way you crop something is you say, 
you draw a rectangle here on the image, and then you say Tools > Crop. 
And now, I've gotten rid of all the rest of that image except that which I want. 
And I'll say save this as, I want to save it as a JPEG tiny. 
And so, I now have two images, I got that first image and this tiny image. 
And there it is. 
I'll use Apple+W to 
quickly close it. 
And so, the one thing is is you just, after a while, 
these snapshots fill up on your desk, and so just keep cleaning them off. 
And if you were uploading to hand in a screenshot or 
whatever, this would be the filet that you upload. 
So that's pretty much all there is. 
Use the preview command to take screenshots with the grab. 
And typically, it's grab window, okay? 
Thanks.
So welcome to the chapter on object oriented programming. 
I have been using terminology all along about object oriented programming. 
I say object, like BeautifulSoup returns the soup object. 
And then I call the find method within the soup object and 
I get back a list, blah, blah, blah. 
And I didn't want to teach you object oriented programming too early in 
the class because until you need it, you sort of don't need it. 
So I've been using these words without defining them. 
So guess what? 
Now is the time that we're going to define these words. 
I'm not going to ask you to write objects. 
I'm not going to ask you to build your programs using object oriented techniques. 
You will eventually love OO, and object oriented. 
And you will be good at it. 
But in this class and in this lecture, 
I just want you to have a few words that you absolutely 100% understand. 
And I'm going to give you some sample code, but not so you can write that code, 
but to help inform your understanding of the concepts. 
because object oriented is something that I think you have to come back to a couple 
of times. 
You can't just like, see it and go, got it. 
Like a lot of things in programming until you really need them, 
it's hard to fully understand them. 
In other words, you've got to start and learn somewhere, and then come back again. 
So the word objects has been in, like I said, a lot of the words I've said, 
we've been reading documentation, they say the word object. What is object? 
Well, it says here the list data type has some more methods.
Play video starting at :1:39 and follow transcript1:39
Here are the ones that list of the list objects, and 
that means the objects of type list. 
And list data type has methods. 
Methods are these things that are functions built into objects. 
And I've said these words before and now I want us, by the end of this lecture, 
to know these quite well. 
So as we're moving our next stuff is we're going to move into databases. 
And database is a connection object and a cursor object and 
an object in a method and call a method. 
Again, I just want you to know these words. 
So let's go back to the beginning and start with programs that we started with. 
And here was our first program that handled input, processing, and output. 
You can draw a boundary around this program, right? 
And then there's kind of like the inside stuff and the outside world, okay? 
And to the outside world, this program does something. 
And frankly, if this is the outside world, 
we do not have to keep track of the detail of this. 
Like we've got this program, we installed it on our computer, 
we're confused about floors and we're in Europe and we say, yeah I'm on floor 0. 
What would be the equivalent US floor? 
Thank heaven I have this application, right? 
And so there is this notion of kind of like inside and 
outside, where we hide the detail. 
Like programmers have to worry about this detail, the programmer that wrote it, but 
a lot of people don't. 
So this is kind of hiding abstraction, there's a lot of words that we use to 
basically say, don't worry about what goes on inside.
Play video starting at :3:1 and follow transcript3:01
And so in actuality, that program had several objects in it. 
The string object, there's an integer object. 
And so what happens is these objects also sort of are like containers of 
functionality, containers of awesomeness. 
And these objects sort of work together. 
And the program itself kind of orchestrates these objects, one or 
more objects working together. 
And the best way to think about an object, it's kind of like a program but smaller. 
It's a little thing that we can draw a boundary around and 
say, there's some code and data in there. 
There's logic, there's data, and we do stuff with it. 
And the idea is you take this big problem and break it into a series of problems, 
like small Lego blocks, 
and then build these things back up to build your program. 
And like I said, we have been using objects the whole time, strings, 
integers, dictionaries, lists, floating points, etc. 
And so if you think of a program, it's going to have different kinds of 
objects that are in it and these objects are going to work 
together to take the input of the program and produce the output of the program. 
And like I said, we've been doing this all along. 
But one other thing about objects is that each one contains some code and some data. 
And you can send stuff back and forth between objects, 
you can make new objects, you can do stuff with objects. 
But one of the things is like okay, if you're in the object, 
you just say oh, this is what this object does and 
I'm not going to worry too much around the world in which I'm embedded. 
And the same thing is true about the outside world. 
We're going to use this object and we're not going to look on the inside of it. 
So from outside looking in, you ignore the detail. From inside looking out, 
you ignore the outer detail. 
And so it's a way to draw a nice bright line and say you worry about this and 
we'll worry about that. 
It's a separation of concerns.
Play video starting at :4:38 and follow transcript4:38
And so some terms that we're going to be using are class, 
object, method, and attribute. 
And so a class is a shape of an object. 
It's a template. 
In the little example, it's like the cookie cutter and 
then the object is like the cookie. 
And so you can say, I would make a bunch of objects. 
So the string is a class. 
We have as many strings, we can have a string called x, and 
we have a string called y, and a string called z, and 
x could have something different than y and z, etc. 
But the class is string. 
And then methods are like uppercase. 
string.uppercase, that's a method. 
That's a capability. 
And attributes are data that's part of a class as well.
Play video starting at :5:21 and follow transcript5:21
And objects, and so we'll get to these.
Play video starting at :5:24 and follow transcript5:24
So class is defining the general characteristics of a thing like what 
fields it has, what properties it has, it is a blueprint for making things, right? 
Class Dog is all dogs but then you would make, each dog then would be an object. 
Then the concept of dog is like a class. 
But when you see a dog and you grab the dog, that's an object.
Play video starting at :5:45 and follow transcript5:45
An instance is another word for object. 
And so this is where we have Dog and then we have many actual dogs, 
or cookie cutter and then many actual cookies, okay? 
And so the object or instance is the word we give to the real things. 
Not the shape of the things, but the real things.
Play video starting at :6:5 and follow transcript6:05
Method is a part of defining a class, it's also part of the object. 
And that is things like string.upper, string.startswith, 
string.find, those are all methods in the string class. 
But they also are part of every string object.
Play video starting at :6:21 and follow transcript6:21
In some forms of object oriented sort of the simpler, prettier, pure, they would 
call it a message, meaning that here's this object, and you're going to send it 
a message to cause it to do something, you would kind of poke it with this message. 
But another way to say it is it's got code in it, and 
we call a function inside the object, and they're kind of equivalent, 
but sort of just one to some people seems prettier than the other. 
For me, I tend to think of it as like code. 
We're calling a function that lives in the object.
Play video starting at :6:48 and follow transcript6:48
So like I said, we've been playing with these objects all along. 
We have a string object and when we print this type thing out, 
now we're going to understand a little bit more. 
And that basically says that x is an object of type class, 
the class string, right? 
So that's the kind of thing, this is an instance of the string class. 
This is an instance of the float class. 
This is an instance of the integer class. 
We make a list, say what is it? 
Well, this is an instance of the list class. 
What is this? 
Type z is a dictionary, and that's a class. 
Now, so these are all the classes. 
Those are the templates. 
You can have many strings, many instances. 
An object, this is the object, this is an object, this is an object. 
We can also ask, based on these things, what are the capabilities? 
And these, that we have seen before, are the methods.
Play video starting at :7:40 and follow transcript7:40
In our x, we've got stuff like upper. 
That's one of the methods. 
In y, which is our list, we can append, we can pop, we can remove, we can sort. 
So there's all kinds of methods in lists and in dictionaries. 
We've got things like items, values, get. Remember get, how we use it in counting? 
well, get is a method that is part of all dictionary objects. 
So we've been playing with these things all along, 
it's just that now we want to make this terminology nice and precise. 
So up next, 
we're going to talk about how you would build your own class in Python. 
And it's not so much that I want you to build a bunch of classes but 
really to help as you look at how we define them to kind of think as 
how a string class might be defined or how you use a string class.
So now we're going to take a look at building a bit of Python, and 
building a class in Python. 
Not, again, so much as, because I want you to write a bunch of code. 
But instead, I want you to imagine as you're using classes, 
that someone had to write this code. 
And so, we're not going to make you write a bunch of classes. 
But we're expecting you to be increasingly good at using 
classes that are built into Python. 
Or come from libraries that you might import. 
And so, here's some code.
Play video starting at ::35 and follow transcript0:35
So class is kind of like a function. 
There's a new keyword called class, and there is the name of the class, 
class PartyAnimal. 
And so that's the name of the class, a colon, and then an indented block. 
And so, it's got sort of a block of text that makes up the class.
Play video starting at ::52 and follow transcript0:52
And as I mentioned, every class has some data associated with the class, and 
some code associated with the class. 
And so here in this class, we just have some variables, x = 0. 
That's an attribute of, all PartyAnimals will all have a variable named x in them. 
And there's a little function. 
So this is now a method, so it has a bit of code, it's a method. 
And then when this is done, it doesn't actually run any code. 
But what happens then is, we have a template called PartyAnimal. 
And this syntax here, that basically says 
make me a PartyAnimal, it's the same as saying x = list(). 
It says mint me a new list, there's a template for a list here. 
And then give it to me, give me that empty list back in the variable x. 
So that's what's happening here, 
mint me a new PartyAnimal, based on the template that's up here. 
And then once that empty, 
or fresh, PartyAnimal is done, then give it to me back in the variable an. 
And so this, then, is that object. 
So that is our PartyAnimal object. 
Using the PartyAnimal template makes a PartyAnimal object, 
which ends up in the variable an. 
Or, the PartyAnimal instance of the PartyAnimal class. 
And then we make a call by taking the name of the object, dot, dot is the operator. 
And then the method within it. 
So that basically calls this code, okay? 
And then it calls it again, it calls it again, 
it calls it again, that you can put parameters here. 
And you'll notice that this party has no parameters, and 
this one has one parameter. 
And basically, you can think of this as, it's kind of like saying, 
go into PartyAnimal. 
Call the party() function within that, and then pass, as the first parameter, 
this variable. 
So that you can almost think of this syntax as 
this is like a contraction for this. 
Which says go in, find this PartyAnimal, and then pass an, 
an the variable comes in as self. 
Now you don't have to name this self, but you can name it self. 
And nearly everyone who writes Python object oriented tends to call this self. 
And self says, self.x = self.x +1. 
Well, that's kind of like saying an.x = an.x+1. 
Because we're calling it in the context of an. 
And so, when we see more than one instance, we'll see how this all works. 
And so, this is basically the object. 
We have the definition, we have the minting, the templating, 
the making of the cookie. 
And then we have the use of that object. 
And so if we trace through the code that's going to happen here. 
There is nothing, there is just the template, and then we mint this. 
And then in the minting, it runs through this and defines these things. 
And then x ends up with the variable value 0. 
And then, this whole object, this whole box is the object 
because it has a variable, an attribute x, and a bit of code called party(). 
And then we take this. It gets returned, and then it comes back as an. 
And so an sort of points at this particular object, 
when this line of code is done. 
So make the thing from the template, and then assign it to an, so 
an points to this.
Play video starting at :4: and follow transcript4:00
Then what happens is we hit this.
Play video starting at :4:2 and follow transcript4:02
And so that calls, that goes up and calls this party, except that an is, 
self is an alias to an. 
So temporarily, self is also pointing to this. 
And then it says self.x=self.x+1. 
So that pulls the 0 out of here, adds 1 to it, becomes 1. 
Stores it back in, which makes this be a 1. 
And then it also has a print("So far",self.x), and 
then that prints out this print. 
Then it returns, goes to the next line. 
The next line goes up to here, passes in an again. 
So self also points to this object, that now has a 1 in it, and it comes in. 
Self.x = self.x + 1, so that's a, it pulls this variable out. 
Adds 1, this becomes 2, it goes back into self.x, so that becomes 2.
Play video starting at :4:50 and follow transcript4:50
Then we print this out, So far 2, then we finish. 
Go down to the next line, comes back up, runs it again. 
This becomes 3, and then it prints out, so far self.x is 3. 
And so that's the logic of it. 
It's just kind of a, so far, it's like a clever way to hide or 
embed a function inside this template. 
Now, in reality they would have multiple methods and multiple bits of data. 
And so it's more complex than this. 
But, for now, 
this sort of just gets us started to understand the syntax of the class. 
What we call the moment of construction. 
This is the moment of construction right here, where it's being constructed. 
And these are the invoking of the methods within the object.
Play video starting at :5:32 and follow transcript5:32
Now, like we've shown, the type() and 
the dir() tell us what kind of things these are. 
And the dir() tells us what the methods available are. 
If we take a look at the thing we just created, so class PartyAnimal. 
And we make a new PartyAnimal and assign it into an. 
And we say, hey, what is the type of an, 
and what is the methods that are available in an? 
It will basically say, an is of type class '__main__.PartyAnimal'. 
That's what it is, and so it says that's the kind of thing that this is. 
The template from which we created an is this template right here. 
And so it knows that, and it remembers that. 
And then dir() says, what are the things in there? 
And you see a bunch of things with underscores. 
Those are internal, but eventually, you see party, which is this method. 
And you see x, which is this attribute. 
And so dir() is looking or inspecting inside here, and saying, well, 
what things are in here? 
And you see party and you see x. 
And so dir(), when dir() is looking into a string, it's doing the same kind of thing. 
It's like, oh, what little functions live inside of strings? 
And that's what we do, we have like strip, split, strip, upper, right? 
Those are the functions that are like in the code that someone wrote a long time ago 
to make strings and define strings. 
And again, it works the same for classes that we define, and 
then create an instance of, and then use.
Play video starting at :7:2 and follow transcript7:02
So up next, we're going to look into a little more detail of this notion of 
constructing and destructing multiple instances of objects.
So now we're going to talk about how objects are built and then thrown away. 
And this is, again, something that's been happening all along. 
Most of the time we build variables, 
you say x equals hello world that sort of makes an object. 
And then when the program ends all the variables get thrown away. 
Sometimes you can be a little more explicit. 
We have terms that we use to describe this, we call it constructor or 
construction of taking the template which is like a pattern and then building it. 
And then that's construction and then throwing that away and making the memory 
available for the rest of the program is the moment of destruction. 
If you say x equals hello world, you've constructed a string and put it into x. 
If you say x equals 12, you construct at 12 and put that in x, but 
you've also thrown away the hello world that was in there before. 
So, destructors kind of happen as we reuse variables or as the program ends. 
And as our objects get a little more complex, 
the primary purpose the constructor is to set up initial values. 
And this has to do with the fact that outside the object you just say, 
make me one of these things, make me party animal. 
But inside party animal it may need some data and 
it may need that data be set to zero or something, who knows what. 
It's initial, but it's something that the moment of construction outside, we say, 
hey, construct me one of these things, and inside, we say, oh, hang on, 
I've got all these little things I've got to get right before this object's actually 
going to work. 
Because think of objects as small programs that we're sending stuff into 
almost like little mini applications that we got an API to talk to. 
Except it's really tiny and it's just really part of our program.
Play video starting at :1:48 and follow transcript1:48
So the way this works is the constructor and 
destructor are specially named methods. 
And so in this case, we make PartyAnimal and so 
far this part's the same and this part's the same. 
But we have an __init and passing in self which is that 
passes the instance of this particular one once it's constructed. 
And all we're going to do is print out that I am constructed, 
this is the same, and then __del is when that thing is thrown away. 
And so that's going to say, I am destructed and 
print out the current value of x for that particular instance. 
So it comes through here, it has a template.
Play video starting at :2:24 and follow transcript2:24
So it's the same as the one we're doing and now we're going to construct. 
So we're saying construct me a PartyAnimal, 
you know the template because I told it to you. 
We're not passing any data into constructor. 
Eventually that will come in as additional parameters. 
Make me one of these things and then, it's sitting here. 
It's got a little x in it, it's got this __init__, it's got this party and 
it's got this __del__. 
It's all, that's an object now, and that comes into an. 
And now we are going to call the party method, and that runs and 
adds 1 to self. 
But at the moment of construction it prints out this construction message. 
Then at the moment of calling that method, it says so far 1, and then so far 2. 
Now this is kind of like inside this an there is an x that's got 1, and 
then we change this to 2. 
We out here have no responsibility for this x. 
The person who built this had made the x and we just get one for 
free because it's part of the template. 
Now we're going to destruct this by saying an equals 42. 
So the way they think about this is an sort of points to this object and 
then we say an = 42 and it makes a new 42. 
And then an points to that, and this is thrown away, and 
then this is thrown away. 
And the moment, that's the destructor moment. 
And so in this line of code it's going to say, 
before we throw this away, ah, you've got to register destructor, call the destructor. 
So in this line of code you see the end. The last thing that comes out of 
this object is I am being destructed and my last value of x was 2. 
And so then this is thrown away and can be reused. 
And then 42 is there and then we print out an contains 42. 
So the end of the program, 
this doesn't have a destructor because we don't have a print statement inside of 
an integer class because we didn't make the integer class. 
But all things are destructed at the end too. 
And so if there was a thing you could see a destructed message after the end of 
the program because that's where all the objects eventually are thrown away and 
put back so that the memory's available for other things.
Play video starting at :4:24 and follow transcript4:24
So the constructor is the moment we ask to say make me one of these things. 
And the destructor is whether if you reassign the variable or 
if the program ends, then all the destructors get called.
Play video starting at :4:35 and follow transcript4:35
So the constructor is a special block of statements that are called at 
the moment of object creation.
Play video starting at :4:41 and follow transcript4:41
Now we're going to talk about what happens when you have more than one instance. 
We've made a template and then we've stamped out effectively one cookie and 
put it in a variable. 
But now we're going to do more than one. 
And the key thing to start to realize is that the template is sort of replicated 
multiple times and then each one can have a different color frosting on it. 
And so there are instances of cookies and 
they can have things like frosting color that changes. 
And so each of the instances has their own set of variables, so 
it's not a class variable, it's an instance variable. 
And so here we have our PartyAnimal.
Play video starting at :5:15 and follow transcript5:15
And so, it's going to be pretty much the same as what we've been doing. 
We have a variable x, we have an internal variable named name, and 
again, this is on the inside, we aren't worried about this out 
here in the main program but they're defining for themselves a structure. 
And we're going to have a constructed parameter. 
So the self is the instance itself which points to the under construction 
instance and then z is this parameter. 
So we're going to take the z that comes in on the parameter and stick in into the name
Play video starting at :5:45 and follow transcript5:45
inside the object and then print out that we've been constructed.
Play video starting at :5:50 and follow transcript5:50
And on and on. 
So that's what going on, that's how the constructor works. 
We don't have an destructor in this particular one. 
And so, as this code runs, this code sort of creates the template, 
then says make me a PartyAnimal and 
I want that to be in with the Sally as the parameter. 
So Sally ends up in here. 
And then S, our variable S, points at that object.
Play video starting at :6:19 and follow transcript6:19
And then we're going to call, And oh, by the way, x starts out at 0 through 
the constructor because the constructor sets up x to be 0 and 
then sets self.name to be whatever this parameter is. 
And then we call s.party and then party runs and adds 1 to x so that becomes 1. 
And then comes it back, and now we say let's make another one. 
And so let's construct this one with Jim, and so it makes another template, 
which means it has an x and a name and some code in it. 
And the x ends up 0 and the name ends up Jim. 
And then we take this thing and we assign it into the variable j. 
So basically j points at this. 
And we say j.party, and so this is where when we say j.party, 
it comes up here, and in this case j, self is an alias for j. 
So its function self.x = self.x + 1. 
That means this one is going to go to 1, because this is j one and 
that's what self means for now. 
So temporarily self points to j. 
And then it prints out self.name, party count equals, away we go. 
And that says this will be Jim. 
And that will be 1. 
And now we've still got s pointing to this. 
And so we can call s.party and this time, this is an alias to s. 
So self points to this guy now. 
And so self.x = self.x + 1 means this x is going to get incremented. 
So these are two x's, two names, but 
they're sort of independently stored in each of those objects. 
And so these are two independent instances, the key here is instances. 
And that's because we minted or caused to be constructed two PartyAnimals and 
then had them in separate variables. 
And so simultaneously, 
each one of them has all the internal structure that they need. 
Now, this isn't a very useful example. Think of this as, you know, you've got a bunch 
of strings, and one in x, and one in line, and one in z, and one in this, and 
one in name, and one in email, and they're all strings with data inside of them. 
And so the variable names kind of are pointing at the objects that have all 
the data within them.
Play video starting at :8:19 and follow transcript8:19
So up next we're going to talk about another method 
of defining the capabilities of objects called inheritance.
So multiple instances are we have one template and 
we make multiple variables out of that template, and they all kind 
of have the same shape because we're starting from the same template. 
Inheritance is a different concept. 
Inheritance is we're going to make more than one template. 
And we're going to have a second template that's related to a first template. 
We call the first one a parent template and the second one a child. 
And idea is it's like we're going to make a class, 
a template, that's everything that's this class has plus. 
We can either add capabilities or extend the capabilities of the parent. 
So the idea is this is just a form of store and reuse. 
And again, don't get too worried about when you're going to use this. 
I really am trying to define for you the notion of inheritance rather than 
teach you how to write inheritance in object orientation. 
That will come in time, perhaps years from now, 
when you actually will actually use this skill.
Play video starting at :1:1 and follow transcript1:01
But it does tell you something about how things are related. 
And if you say this extends that, then you say, okay. 
That just means that all of the features of the thing that's being 
extended come in. 
Another term for this is subclasses. 
A subclass is a more specialized version of a parent class. 
Sometimes you have a parent class and a couple of different subclasses. 
The parent class might be animal and then you might have a dog, a cat, and 
a bird, right? 
And so there are things that animals have 
or mammals, might have animal, mammal, dog, cat, right? 
And so that might be a hierarchy of classes. 
Now, don't get too stuck on that. 
It's just a form of storing and reusing a functionality so 
that you don't have to repeat yourself. 
And it's not like the more inheritance you use, the better your programs are. 
Sometimes that's not true at all. 
But we programmers just hate repeating ourselves and so if we can do it once and 
then reuse it, we like that. 
And so that's really what inheritance is there for. 
So here's a bit of code. 
This first part is unchanged. 
So we have a class called PartyAnimal. 
It's got two variables, name and x, that are attributes of that. 
We have a constructor, and 
the whole idea of the constructor is just to grab that name parameter. 
And then we have the party, which just adds 1 and 
prints out the current party count. 
And that's fine, we've done that before. 
Now we have a new class. 
So now we say class FootballFan and 
in parentheses here, we have the name of a different class. 
So what we're saying is PartyAnimal, 
FootballFan is everything that PartyAnimal is plus whatever we define down here. 
Okay? So this is like an extension.
Play video starting at :2:41 and follow transcript2:41
It's as if all this was pulled in, and then this is addition, okay? 
So a football fan has an x instance variable, a name instance variable, and 
a points instance variable. 
And has a constructor, a party method, and a touchdown method. 
And so all of these tings, all this stuff is stuck right there. 
It's like it came in by us saying, 
the way I read this in English is class FootballFan extends PartyAnimal. 
Which means it includes everything PartyAnimal includes plus this extension 
stuff that we're going to add, right? 
All the capabilities of PartyAnimal and more. 
And so if we're going to use these, I mean the fact that we've extended, 
it doesn't mean that this one goes away. 
And so we can still construct a PartyAnimal with the name of Sally and 
call the party method in that, and that does what it does. 
And then we can make a new object using the FootballFan template. 
So, and give it a name, and 
that FootballFan actually calls, there is no constructor here and 
so it's actually calling this constructor, the one from PartyAnimal. 
Because PartyAnimal is included in FootballFan. 
And it's setting the name, and x to 0, and the name to nothing, and 
then points to 0 also happens. 
So all three variables are present in this j object. 
And then we call the party method, which is really here. 
Runs the code. 
But then we also have now a touchdown method that can run this code, okay? 
And so you can see that this FootballFan has every capability 
that the PartyAnimal has, plus one more capability that we've added. 
And so that's the basic idea of extension. 
You know, s.x is 0, the name is Sally, it runs s.party so x becomes 1. Right? 
That's just a little object with a name s and away we go.
Play video starting at :4:33 and follow transcript4:33
If on the other hand we look at this next bit of line of code, right here, 
we end up with a FootballFan and a FootballFan inside of it has an x. 
It has a name and it has points. 
And at moment of constructor, x is 0, 
name is Jim, and points is 0. 
Then we call the party method.
Play video starting at :4:53 and follow transcript4:53
And the party method changes the x to x plus 1, so that becomes a 1. 
The touchdown method, I add 7 to the points so that becomes 7. 
And then it calls the party method, 
and so it's calling within itself the party method.
Play video starting at :5:7 and follow transcript5:07
And so that calls that code and that causes this to turn into 2. 
So even within this method, you can call other methods. 
And so this j object has everything that the s object had and then some.
Play video starting at :5:24 and follow transcript5:24
So again, 
I just want you to get these words, classes, we have attributes and methods. 
Attribute is data, method is a function that's part of a class. 
An object or an instance is what we construct from the template. 
So, class is the cookie cutter and object is the cookie. 
And a constructor is a bit of code that runs at the moment of object creation, and 
inheritance is the ability to define a new class and 
add the existing capabilities of an existing class to make that class. 
And so that's kind of the definitions. 
It's a, you look at it and you say, why did they invent this? 
And that's probably the right logic to have right now, 
because you haven't written programs that are complex enough to require 
object orientation in terms of the code that you write. 
But we've actually been using object orientation all along 
because it's a way to group functionality. 
Something like something as complex as beautiful soup or 
our SQLite connections. 
Those things are actually complex data and code and 
we don't have to worry about that, and so the benefit to us right now is it 
simplifies our programs to make use of objects that others create.
Play video starting at :6:32 and follow transcript6:32
Some time from now, when you become a more sophisticated programmer, 
you're like I've got to solve a problem and 
I'm going to start creating a bunch of objects to solve those problems.
I had the great privilege and good fortune of being exposed to Simula 67 
which was after 67, I'm not that old. 
But still Simula kind of was the was still the dominant view of object 
oriented programming at that time, which very, very few people had encountered. 
So Simula was the first object oriented language, and 
well it was quite confidential. 
So kind of best kept secret for many years, but I got introduced to it, 
and I immediately knew that it was the right way to program, 
it was pretty obvious, at least to me. 
And so for a number of years I worked with Simula both on paper, 
to help my research work, and to build systems. 
>> Bertrand was teaching at UCSB and well, 
of course, he had already in France started some projects. 
So his ideas, 
he came already with some ideas and projects to UCSB. 
And he continued, and he shared that with his students, and 
suddenly one night he comes back home and says, well, I have a student 
from Japan who is excited about my ideas and 
he wants to talk to his company about it. 
I said okay, well. 
It was a new idea. 
Why not? 
But I did not really believe in it. 
But several months later, Bertrand came home and 
said well the company is interested in my ideas, 
and they are ready to start to help us start a company. 
So there it was, and that was the beginning of the second adventure. 
The first adventure was the move to the U.S. with five children. 
>> I found myself in '85 in Santa Barbara with a newly created company, 
building a system which was called ArchiText and 
which was a very smart editor, 
on initially with funding from a Japanese company.
Play video starting at :3:1 and follow transcript3:01
And well I was looking for a tool to build it, to build that system. 
And while Simula was kind of fading out at that time I looked 
at C++ which was there. I opened the book, I closed it pretty quickly afterwards. 
There was Objective C, there was SmallTalk, these were all interesting developments. 
But they didn't really correspond to the kind of strict software engineering 
standards that my colleagues and I had learned to observe, so 
we developed our own language which was based on, 
well the full story would, of course, be longer. 
But I had written a book which I never finished, but which had a very precise 
notation for expressing algorithms at the time, so I used that. 
I used my work on formal specification. 
I co-wrote the first paper on the Z specification language. 
So my work on Z and also a successor to Z, which was called M, 
was also very influential. 
So, over a half a day, I kind of put all these together and 
we implemented a pre-processor to, well, 
we thought of it right from the start as a compiler to generate C. 
But it was really just for internal purposes. 
And then what happened is, that we went to OOPSLA. 
The first OOPSLA in '86, where the company had booths, or rather a makeshift booth. 
We didn't have that much money. 
But then we were actually showing the other tool but 
people wanted to see Eiffel. 
>> Well at OOPSLA, Bertrand had some tutorials and 
that was the first place where Eiffel 
was really exhibited, and from then on it was clear 
that the focus of the company was more on that technology, 
on the tools to help programmers
Play video starting at :4:57 and follow transcript4:57
make the most of power of object oriented technology. 
>> We realized that contrary to what I had thought, 
no one else had anything similar because everyone else was going into 
these kind of AI-oriented developments, experimental programming, no typing, 
no idea of course of generativity because without typing there is no need for that. 
Or the kind of C++ direction, which is of course also respectable, but which to us 
was a diversion, or a transition to help people move to the object oriented world, 
but didn't seem like an end in itself. 
And I'm not saying this to deprecate C++ because obviously it's been a very 
successful technology, 
but to still think that it's best viewed as as a transition technology. 
So we realized that there was nothing like it and when we came back from 
OOPSLA we started kind of refocusing the company. 
And there's also something very important which happened at that time. 
Which is that people who started playing with the language, 
even with the primitive implementation we had at the time, 
started telling us. you know, there's something absolutely new 
which I've never seen before, it's how easily you can change your mind. 
And I would say today this is still one of the major assets of Eiffel is 
the flexibility, to use the technical term, the extendability. 
So the people don't necessarily believe us when we say this because it's like hand 
waving and to some extent everyone says, oh people talk about flexibility. 
But this is perhaps one of the major differences between Eiffel and 
other technologies is how easily you can have a first design, a clean design. 
I'm not talking about agile style hack it and see if it works. 
Really, a good design, which however is not perfect, 
you realize it is not perfect, you change it and 
you don't spend your entire life paying for the sins of your youth, so to speak. 
And it's not one single aspect, 
it's not one single feature of Eiffel, it's a collection of things. 
It's contracts, it's the modularity mechanism, the information hiding mechanisms. 
It's the principle of uniform access. 
Something that Simula actually had got right, but later languages didn't. 
The idea that you don't distinguish from the outside 
between accessing a piece of data and calling a function. 
Which even UML which should be high level, didn't quite get right, so that's 
it's a whole set of seemingly small properties, that together make a,
Play video starting at :7:46 and follow transcript7:46
give a framework in which you can change your designs and 
integrate new ideas very easily and very quickly without suffering too much. 
So this is what people started telling us right from the start and 
which really encouraged us to build the company, the technology around Eiffel. 
To characterize the typical Eiffel user, 
well this is someone who typically has a difficult application. 
So an application often for which he or she has tried something else before. 
Maybe a couple other technologies that failed. 
You know hit limits of complexity or limits of reliability and 
then doesn't have a choice and he wants it really to succeed. 
And so it can be in the financial industry where 
some of our biggest customer applications are, it can be in the aerospace industry, 
which is also another strong area for us, it can be in healthcare, sometimes also 
of course in education which is kind of a different kind of application of course. 
But it's people who just cannot afford the stuff to fail. 
So that's one characteristic, it's that the reliability and 
quality requirements are typically very high. 
often with continuous operation for systems 
managing to wait for, this kind of thing. 
A second characteristic is that these applications often need to undergo 
much change 
over their lifecycle, which may be years or decades. 
And here the extendability mechanisms of Eiffel really shine. 
One of the key distinctive features of Eiffel is that it's a lifecycle approach. 
So it's not just for programming. 
Not only is it not just a language but also it is not even as a language 
it's not just for programming. 
It's for analysis, it's for design, it's for implementation, it's for maintenance, 
it's for testing, and so on. 
So it's really, it's kind of a holistic, 
to use a pretentious term, view of software development. 
So this is kind of really still going against the grain of the software and 
engineering culture today. 
Most people think they need some kind of high-level requirements tool, 
some case tool to do analysis and design, 
and then Eclipse or something or Visual Studio to do implementation, and 
then JUnit or something like that to do testing, and 
what we do is that we integrate everything. 
Which means that for the developer you don't have this need to
Play video starting at :10:23 and follow transcript10:23
switch between Dr.Jekyll and Mr. Hyde all the time. 
To switch personalities. 
To switch gears, context, and so on. 
You stay in the same conceptual framework. 
And the basic ideas of Eiffel which are classes, inheritance, single and multiple. 
Multiple inheritances are important. And of course, as you pointed out, contracts, the
Play video starting at :10:44 and follow transcript10:44
use of formal precise specification elements in association with every piece of software, 
these ideas and a few more apply throughout the lifecycle, 
throughout the process, from the highest. most abstract 
levels of thinking about the system, all the way down to the nuts and bolts, 
the nitty gritty of software construction, debugging, testing, and so on. 
Although debugging, as you say, we try to have less debugging with Eiffel but 
well, you wouldn't believe me if I told you that there are no debugging at all 
when in fact there is a quite powerful debugger in the environment. 
[MUSIC]
[SOUND] Hello this is Chuck here, and 
we are in London at the Hammersmith Tube Stop. 
We just had about an hour of Office Hours and 
I'd like to introduce you to some of your fellow students. 
Say your name and say hi to the rest of the students. 
>> Hi I'm Jerry. 
Hello. [LAUGH] 
>> Hi, my name's Nico. 
And this is my first course I ever did online. 
It's great. >> Hi, my name's Magic Magic, 
and I appreciate the course, and everything like that. 
>> Oh, hey. 
Get your certificate out. 
I'll come back. 
Get your certificate out. 
I'll come back to you. 
>> Hi, I'm Tara, and I really enjoyed this course.
Play video starting at ::39 and follow transcript0:39
>> Hi, I'm Nick, and I, too enjoyed it, very very much indeed. 
>> Hi, I'm Jonathan, and I'm cheating slightly this course, because I remember 
a lot of this stuff, but with my history, it's been really good. 
>> Well, cool, let's take a look at your certificate. 
So you were in the previous course, right? 
So you got a certificate, and we got the certificate signed so, okay. 
So there we have it. 
Another successful Office Hours here in London. 
So see you all on the net.
So now we're going to move into talking about databases. 
And it may seem a little strange to be talking about databases in a programming 
language, but we are using this programming language for 
doing data analysis. 
And so it turns out that it's quite often necessary when you're pulling data, 
especially data you're pulling over a network, where you might be rate limited, 
or you want to store the data in a database. 
You have a process that reads the data and puts it in a database, and 
then you can analyse it out of the database. 
And it makes some of your processes go really fast. 
It allows you to change your analysis, and 
not lock your analysis into the retrieval of the information. 
So it speeds up your overall workflow, but you have to learn a bunch of stuff so 
that you can put the information into your database. 
Now, the first task that you have is to install your database browser. 
There's a couple of different ways to read and write these files. 
We're going to use Python to read and write the files, but 
we want a way to read and write the files directly. 
And so this is code that you can download for the Mac, for Windows, for Linux.
Play video starting at :1:8 and follow transcript1:08
There's also a Chrome plugin that you can get for SQLite, 
that you could do everything that we're doing in the class. 
And so I don't really care how you achieve the things you're going to achieve in 
the class, because we're going to grade you, not so much about what, how you use things. 
But instead, we're going to look at, you know, the databases that you produce, okay? 
So stop now, download this, install it. 
It should be simple, should be easy. 
Check with the forums if you have some problems.
Play video starting at :1:37 and follow transcript1:37
So relational databases are a whole subfield of computer science. 
And it might be best to talk about what life was like before relational databases, 
and you use relational databases thousands of times a day without even knowing it. 
If you imagine something like a learning management system, 
where there's hundreds of thousands of users, and terabytes or petabytes of data, 
and you log in, and within a half a second it shows you what you're supposed to see. 
You can't read a petabyte of data in a half a second, you just can't. 
And in the early days, we used to have data that was small
Play video starting at :2:22 and follow transcript2:22
and computers that didn't have a lot of storage in them. 
So we tended to use tapes and 
we would put the data like on a magnetic tape, and we would sort the data. 
We would have old bank balances on one tape, we would have the transactions, 
and then we would read one balance, check to see if that transaction had changed, 
then we would store the balance. 
And you would have like last night's bank balances, and tonight's bank balances. 
And then the next day, you would put this over here, and 
read the old bank balances and make changes. 
And this is how, day after day, in the 60s and the 70s, we would update data. 
If you look at old computer videos, you'll see these little spinning things. 
Well those are tape drives, and 
that's where most of the real data was stored, and it was. 
But as computers got faster, as they got more memory, and 
as we started to store data more in the memory of computers and 
on the disk drives a whole different way, so 
you didn't have to read to get through the account where it starts with the letter s. 
You didn't have to read through all the data from a through s just to get to 
my account that starts with s. 
And you'd be like oh, wait a second. 
We have a disk drive that we can skip all the way and skip back and skip over here. 
And so the problem became how to make sure of this random access medium in 
which we can store data in a way that's efficient and fast and clever. 
So just because you could randomly access the data didn't mean it was fast. 
You still had all the data to look at and if you just looked at it sequentially, 
so relational databases were this applying cleverness 
to how we would use random access data storage, mostly disk drives that spun.
Play video starting at :4:9 and follow transcript4:09
And it really sort of emerged in the 60s and 
the 70s, and whole companies were formed like Oracle.
Play video starting at :4:18 and follow transcript4:18
Oracle exists because smart people figured this problem out 
before other smart people did. 
And so they got to form a company and 
Oracle's the leading database vendor on the planet and much of its revenue 
comes from its database product and things built on top of its database. 
But literally before 1960, the concept of database really wasn't an idea. 
It was something that happened as storage and what we wanted to do with computers. 
So this is where, if you had to really read a tape to log in to a computer 
it might take four hours to log in. 
Which would be unacceptable in this modern day and age.
Play video starting at :4:56 and follow transcript4:56
As I mentioned, the database is sort of this technology that emerged and 
it emerged from a lot of theoretical analysis and the 
underlying foundations of database have to do with some really powerful mathematics.
Play video starting at :5:8 and follow transcript5:08
And so there's powerful mathematics and it still is present 
in some of the terminology that some people use to describe databases. 
And so there's really kind of two parallel terminologies that you will encounter. 
You'll pick a book up and you'll kind of be able to read it and say oh, 
this is using the highfalutin hoity-toity language, which is the more math-oriented. 
So in the more math-oriented, we use the words relation, tuple, and attribute. 
That's kind of the fancy way of speaking about it. 
But sort of we programmers who just do our thing, 
we would call it a table, a row, and a column. 
Now, table and row and column is kind of the wrong way to think about it 
if you're trying to understand the true underlying amazing mathematics.
Play video starting at :5:54 and follow transcript5:54
The underlying mathematics, don't worry about the underlying mathematics. 
Just be aware as you're reading, 
don't be surprised when people lapse into this more fancy nomenclature. 
So the idea is that you model data at a connection point rather than like, 
here's data and we're starting here and we're reading through it. 
The idea is if you model everything as a connection, like who a person is. 
A person is a connection between this, that, and the other thing. 
And so this notion of modeling stuff at a connection 
is the underlying math that makes databases fast, but 
when we programmers think about it we kind of think about it as rows and columns. 
And so here's just a screenshot of a spreadsheet that I made. 
Along the bottom you see the names of the various subsheets, 
tracks, albums, artists, genres, and titles. 
And those are like the database tables. 
And then each table, if you select it, has a row and a column. 
So it's got these columns. 
This has three columns in it and it has a bunch of rows. 
The other thing, when you're doing stuff in a spreadsheet. 
You just kind of come up with a data model, a schema, a strategy so 
that you know that the first column is always the title, the second column is 
the rating, because if you didn't label it, it would make no sense. 
So we often do something where the first row of a spreadsheet 
is kind of metadata about the columns, right? 
Now, the spreadsheet doesn't exactly know that you're doing it. 
Even though some of the things you do, like sometimes it sorts and says, oh, 
check this tickbox to say the first row is title, so don't sort it. 
So when you sort stuff you only sort like the bottom part of it, right? 
And so it sort of knows it's the title. 
But in a database this becomes what we call the schema.
Play video starting at :7:42 and follow transcript7:42
All this, all these titles and 
we have rules like these have to be integer numbers, this has 
to be an integer number, this has to be string no more than 128 characters. 
So we make strong contracts about the content that sort of at some level feels 
very similar to what we´re doing when we´re writing these titles. 
But in reality, as you'll see, it is far more complex and far more intricate. 
Now, if you've ever tried to do something like we're going to do with this database, 
and that is categorize your music collection, you find that a spreadsheet is 
a really hard way to categorize your music collection because of so 
much repeated data. 
And we'll figure that out in databases.
Play video starting at :8:19 and follow transcript8:19
So the idea that they came up with in the 60s and 
the 70s is there was a way to represent data on a disk. 
And it could be randomly accessed and 
there was pointers that pointed to something else, and whatever. 
And in the early days they figured out how to technically solve fast access 
to lots of data by hopping in various ways, indexing, doing clever things. 
And the early ways that we programmed these databases is we sort of revealed to us 
application programmers, the low-level capabilities of read this thing, 
then jump to this other thing, then read this other thing, 
then jump to the other thing, read this thing, jump to this thing. 
Which made our lives really difficult. 
And so we had to write really sophisticated programs, but 
when we did they could function very rapidly. 
So what happened over time is instead of our code talking directly to the files or 
the databases, 
instead, a layer started to build up 
that we call the database application, database. 
I'm not doing a very good job drawing, right? 
So here's our database, and it has lots of complexity in it. 
And originally, we sort of just talked straight to that complexity, but 
after a while we would have a database application. 
And then our application, our code, would talk to the database application, and 
the database would know all the magic stuff. 
And it was what we call in computer science an abstraction, 
which means that our job, this is us, and 
our job was easier because the complexity could all be hidden here. 
And so the question becomes, then 
how do we talk to this really powerful piece of software that we call a database? 
What is living here? 
What is the way we communicate? 
Sometimes we would call this an API, application program interface. 
So this is our application.
Play video starting at :10:8 and follow transcript10:08
This is actually another application, the database itself is an application. 
And so we have to have an interface so 
that our application can talk to the other application. 
And just like in the previous lecture this is like a service. 
It's taking care of it. 
And ultimately, let me change the color here. 
It's getting kind of messy, we can sort of think of this thing right here, 
both the data and the software that understands the shape of the data, 
as just a service in a service oriented architecture. 
So once again, what we have to do is define, to use the service 
oriented architecture, the cut point. 
What is the cut point between our application and this magic stuff? 
And this is Oracle. Right? 
So it's lots and lots of money. 
And it's amazing, it's just really good software. Right? 
Oracle is really good. 
Microsoft is really good.
Play video starting at :11:1 and follow transcript11:01
So what happened was, we decided to create a standard at this point. 
The industry did. 
The folks got together with the National Institute of Standards and Technology, 
NIST, and they agreed on a language 
that was the API between an application and a database system. 
And the name of that thing they came up with was SQL, or 
the Structured Query Language, okay? 
And so that means that, wow, I've made such a mess of this, 
I have to start over again and draw another picture. 
Right? 
So that means that over here you could have Oracle. 
Over here you could have Microsoft. 
And here you could have APP1. 
And here you could have APP2.
Play video starting at :11:43 and follow transcript11:43
And APP1 could talk to Oracle, or it could talk to MySQL. 
Or APP2 could talk to Oracle, or APP2 could talk to MySQL. 
And so because they use the same communication between Oracle and 
MySQL, that means that you can write an app that's portable 
between different databases. 
And, it turns out that this SQL is a beautiful language, 
it's just a gorgeous language. 
The reason I don't teach SQL as the very first programming language is you 
would be ruined.
Play video starting at :12:10 and follow transcript12:10
If you learned SQL you would never want to program in any other language. 
I think it's the most beautiful language that I've ever encountered. 
It's beautiful because of its simplicity and its expressiveness, and 
its power, but then it's a very beautiful and elegant language. 
The problem with SQL is, it depends on the data being pretty. 
It's a great way to write code about really gorgeous data. 
So part of what we're going to do is learn how to make the data look really good, 
and then write really cool stuff. 
Python, on the other hand, is a little rough around the edges. 
But it also has no problem dealing with unstructured data, or 
data that is imperfect, or whatever. 
And you can just keep writing more Python. 
And eventually you're like oh man I thought it wasn't as complex at this. 
I got to add a little bit of if statement here and 
add another if statement there and do another thing. 
So Python handles unstructured rough data much better than databases and 
that's why Python plus SQL is such a powerful thing. 
Python cleans up the data. 
SQL is a great way to store and retrieve data. 
So what SQL does is it has four basic functions. 
We call it CRUD. 
Create, read, update, and delete. 
Update is missing here.
Play video starting at :13:26 and follow transcript13:26
CRUD.
Play video starting at :13:29 and follow transcript13:29
So that's a database term. 
It's CRUD. Create, read, update, and delete. 
So up next, we're going to talk about how you as the application developer are going to 
interact, both in large projects and in small projects. 
Small projects are going to be the more typical thing that we use in this class. 
So that's what we're going to talk about in a bit, and 
how you use software to interact with databases.

So now we want to talk about how we place the database and 
the database software in relative to the other 
aspects of the programming environment that we're going to build. 
And we're going to talk both about large projects and small projects. 
And a large project would use sort of a web site. Like, 
you know maybe you build a web site to track comic books or something, and 
you store all the data in the database. 
And so, in a large project, and we're not going to do it in this, so much in this 
class, but I figured it's time now that we're learning about databases to sort of 
give you a sense of how they're used in these online systems. 
And maybe in a future course you'll see how they're used, 
and learn how to do this in large projects. 
But there are generally sort of two roles. 
One is the person who writes the application and 
produces the user interface for the application, and for the web site. 
And then there's the other that actually sort of monitors and adjusts the database, 
and that person is the database administrator.
Play video starting at :1: and follow transcript1:00
Often in a large project, 
you will get some advice as an application developer from a database administrator. 
And the idea is is that database tuning and 
monitoring is a somewhat specialized job. 
And so in a professional environment, 
like the open source learning management system that I work on named Sakai, 
in production I don't get as a developer, and so that's who I am. 
This is me, I'm a developer. 
I write cool code, I make really neat widgets for the end user, and 
this is the end user in a web browser, talking to my cool thing, 
and I add a little button and stuff like that. 
And I write code that actually talks to the database, the database server, 
which is both code plus the data storage itself. 
And I write code that talks SQL to the database server and gets data back, and 
then formats it for the end user, and that's what developers do. 
They're the ones that create application software.
Play video starting at :1:55 and follow transcript1:55
The database administrator, generally we don't let the developer talk to 
the production database directly, because we're afraid the developer will break it. 
And that's probably because there's been a lot of experience where 
developers broke it. 
So, we have a special person called the database administrator. 
And they're the ones that are allowed to talk to the database. 
Now, because the database is both storage 
and software, it can take SQL queries from many different sources. 
Both the application, or database tools. 
And so the database administrator has like a direct way to talk to the database and 
get data back. 
And so if something's going wrong, like a, it's gotten really large, what's going on? 
So the database administrator will start running commands straight to the database. 
Whereas the developer generally has no access to the real database, 
Eventually we can write a new version of the application software. 
And so that's kind of the split between the roles between developer and 
database administrator in large projects.
Play video starting at :2:55 and follow transcript2:55
And the database administrator helps with the design and implementation. 
And often a database administrator is shared 
across a number of software projects. 
But that's not exactly what we're going to do, right? 
So it'd be nice, and maybe you have a job. 
Maybe you do have a job that there's a database administrator, and 
it'll kind of look like that. 
But right now, during this class, we've met the database 
administrator and the application developer and they're both you. 
Okay? They're both you. 
Or me. 
Right? 
And so what's going to happen now is you get to do both roles. 
And later, if you have somebody to help you with it, 
you might turn more into the developer side, or 
more into the database administrator side, that's perfectly fine. 
So we still have a database system, right? 
And that's got both the logic, the software that makes the database smart, and 
the data itself, and we talk to it. 
And the program we're going to use initially right now, 
is we're going to study the DBA way of doing business. 
You're going to write SQL, you're going to talk to this little piece of software 
that's going to submit stuff directly. 
And so, you are going to act as a database administrator. 
We're going to create tables, put data in them and 
we're just going to type stuff into this application called SQLite browser. 
There are others of these applications that are like database administrator 
applications. 
Much later, much later we are going to start writing Python programs. 
And in those programs we're going to talk to the same database files using SQL. 
And we're not going to write programs that have a web interface. 
That would be like Twitter or Comicbookregistry.com or whatever. 
We're going to have various sources of inputs. 
Sometimes files, sometimes network, and 
we're going to write programs that read this stuff. 
And clean it up. 
Often there's a cleaning step.
Play video starting at :4:48 and follow transcript4:48
And then we are going to write the data into a database. 
And so we're going to grow this data, fill it up, and then we'll sort of be done 
with this phase of acquiring data, and all our data will be sitting in a database. 
Then we will write another Python program to read this data and 
maybe make a pretty file. 
And even later in the class, we will be visualizing that or 
sending it to various other places. 
You might send it to R to do statistical analysis, or 
Excel to do some simple analysis or visualization, or 
we'll use JavaScript to make pretty pictures and spinning things and whatever. 
So, the basic pattern here is it's the same. 
We're going to have sort of apps and then we're going to have DBA. 
But they're both you. 
So the thing we're going to focus on first is right here. 
The database we're going to use is a thing called SQLite, and the software we're 
going to use is what I told you to install right at the beginning, a while ago. 
Hopefully you've done that, SQLite browser, because otherwise you can't 
talk to the database, unless you have something equivalent to this. 
And they do exist. 
But the basic pattern is, read data, clean it up, 
stick it in the database in a sensible and organized way. 
And then write other applications to make sense of it and analyze the data. 
And that's what we're going to be doing coming up.
Play video starting at :6:7 and follow transcript6:07
So, when we build this data, I mentioned the word schema, right? 
That we come up with a contract for 
exactly the way the data is supposed to look. 
And with this contract, 
the database software can make the best use of itself, right? 
It can make good use of the disk drive. 
It can make good use of all these other things. 
And so, we call this the database model. 
And it's best thought of as a contract.
Play video starting at :6:32 and follow transcript6:32
Okay, we're going to talk into this file. 
There's going to be magic things that are stored in here. 
We use this database software. 
And the schema is our way to inform 
the database how we think this, how we're going to use the data and 
let the database figure out the way to play it, where to put it. 
I'll put this thing over here, I'll put another thing over here, and 
I'll put a little shortcut over here. 
We don't care about that. 
We say this is the data model we're going to work with, and you the database code 
are supposed to be really smart and figure out how to make the most sense of that. 
So the data model is not just the SQL to query it, but the data model is our 
contract about the shape of what we're going to store and retrieve in our database.
Play video starting at :7:17 and follow transcript7:17
So there's a number of common database systems, I've mentioned several of them. 
Oracle is awesome. 
It's a company that was effectively created just to make a database system. 
And they were founded at the birth of the relational movement, and won 
because they were very good at it. 
The others who didn't win were like IBM, and others, 
although they all had relational databases as well. A lot of those other 
vendors who let, well I don't think letting Oracle win is the right word. 
Those vendors that Oracle 
out-competed were the ones that didn't embrace this relational stuff. 
Because I was in college when they saw what was coming down and 
some of us were like, ah, relational, too much math. 
Give me the quick, dirty stuff, right? 
And it took a while for the relational model really to win, 
but when it won, it won big time. 
And Oracle was a company that made a bet on it winning. 
And so by the time we all realized, whoa, it's a good idea, 
because we all thought it was a bad idea, or at least I did, it was too late. 
Oracle had the best implementation of the good idea that we all 
finally realized was a good idea. 
And so, Oracle kind of wins. 
So then what happens is Oracle's kind of the old dog in the marketplace, 
the very expensive, commercial, a lot of people think it's simply the best. 
But there's alternatives that are quite nice. 
There's MySql, which is a open source.
Play video starting at :8:48 and follow transcript8:48
MySql has been purchased by Oracle, but continues to be open source. 
If you really want to be open source, there's a MySql MariaDB. MariaDB, it's called. 
It starts with an M on purpose so 
that it starts with the same letter as that. 
So MariaDB is a copy of the open source version of MySql 
which was made at the moment that MySql was purchased by 
But MySql remains open source so a lot of people who use 
MySql are switching to Maria, but a lot of people just keep using MySql. 
And if Oracle does something bad with MySql, we'll all switch to Maria and 
that'll be the end of that. 
So at that point, Oracle hasn't done anything really bad with MySql, 
and so it's okay. 
So we tend to use MySql for online web sites, a lot of web site stuff. 
Oracle tends to be used for enterprise kinds of things. 
And then another one that's very popular is SqlServer, it's the Microsoft one. 
You may have even used Microsoft Access and 
you might have even done like a screen, where you're dropping things down 
that turn out to be SQL under the covers, don't know. 
SqlServer for Microsoft is a very good product. 
Some enterprise organizations are all Microsoft and so they use SqlServer. 
Don't feel bad, pretty much everything I'm going to talk about 
applies equally to SQL because SQL's a standard and that's nice. 
There's another one called Postgres that's also open source 
that's very nice and it's kind of more of an imitation of Oracle than MySql. 
MySql is designed to be simpler and faster and 
solve less problems than Oracle, but do them super fast. 
And that's why it's often very popular in web sites. 
Postgres is sort of more of a rich database 
that's very much a direct competitor of Oracle. 
MySql is its kind of own world. 
And we're not going to use any of these. 
If you go take sort of a web class, you will probably use MySql and 
everything I'm going to teach you in this class is useful there. 
Okay? All the knowledge, all the SQL. 
But we're going to use a thing called SQLite. 
Lite meaning little, tiny, not very heavy. 
And so, SQLite is what's called an embedded database.
Play video starting at :10:58 and follow transcript10:58
And MySql or Oracle are whole pieces of separate software 
that we sort of talk across a network connection to. 
But SQLite is actually part of software, and so it's built in. 
Your car, if it's a reasonably modern car, 
probably has five copies of SQLite in it, right? 
So your car has SQLite. 
If you have a fancy music player in your car, it probably is using it. 
If you have an iPhone, it probably has 30 copies of SQLite in it, because 
SQLite is designed to be really small, so small that you actually don't have 
to separate it, you just build it into the application, and 
the thing that matters most to us is that it's built into Python. 
It's already there in Python. 
So that's super awesome, right?
Play video starting at :11:48 and follow transcript11:48
And it's fast and aimed at smaller amounts of data, but 
because in Python we're doing data analysis, we will make good use of SQLite. 
And the fact that it's built in just makes our life really simple. 
We don't have to install a bunch of software. 
Python has it with nothing more than an import statement. 
You know how this story goes. 
If you're in Python and you've got to get something done, 
the first thing you do is figure out what import statement you need. 
Okay? 
So that gives us a sense the of the SQL applications that we'll be using. 
Up next we're really going to start writing some SQL. 
Make a database and put some tables in it, and put some data in those tables.

So now we're going to get to the heart of the matter, 
we're going to actually write some SQL and we're going to make a database. 
Okay, you hopefully by now, 
I've told you a couple of times, installed the SQLite browser. If you haven't, do it. 
You could also write a Firefox plug-in 
that can be used to manipulate SQLite databases. 
I used this before SQLite browser came out with their newest version. 
So, everything I'm going to do could be used by either one. 
And there might even be a way to do it with an SQLite 
admin tool if you downloaded like a MAMP or an XAMPP. 
So it doesn't matter. 
You just need some piece of software that gives you a place to type SQL, 
You hit a go button, and it sends it to the database and comes back. 
That's all you need. Okay. 
This is what it looks like, SQLite, SQLite browser. 
So let me go ahead and start this thing up.
Play video starting at ::56 and follow transcript0:56
SQLite browser, and there we are.
Play video starting at ::59 and follow transcript0:59
Database Browser for SQLite.
Play video starting at :1:3 and follow transcript1:03
And what it basically does is this is going to read and write a file. 
And that file that it's going to read and write is in a very specialized format 
that's highly optimized for rapid retrieval and rapid storage of data. 
And so we'll start by saying New Database 
and I'm going to pick a place on the disk. 
I will put it in the desktop and python for everybody, databases
Play video starting at :1:31 and follow transcript1:31
and I'll call it sql1.
Play video starting at :1:37 and follow transcript1:37
That'll just be the name of the database. 
Now, it's writing to a file. 
This file is not something you should read using anything other than a SQLite library. 
It's a funky looking file. So we're going to save it, boop. 
And it's asking us if we want to create a table. 
I'll just hide that thing. 
So we have no tables, no indexes, no views, no triggers, no nothing. 
And we have a place that we can execute SQL. 
So when I said you're a database administrator, 
we got a file back there called sql1 that everything we do is actually reading and 
writing to that file, but we don't write code to touch that file directly. 
We always are using the SQLite library, okay? 
So we're up, let's create a table. 
Now this is our first SQL. 
And so CREATE TABLE and then the name of the table, Users. 
I'm just going to use upper case. 
Upper lower case generally matters. 
There are a few weird situations where it doesn't matter, so 
just pretend that case matters in this situation. 
And it teaches you something right away about SQL. 
SQL is designed to be somewhat conversational. 
And so the keyword, CREATE TABLE, 
is kind of like one keyword, we're creating a table. 
Then the name of the thing and then a parenthesized list of the fields and 
then the types of the field, that's what we're dealing with. 
So this is CREATE TABLE named Users, and we're going to put two columns into it, 
and one is of variable length character, up to 128 characters, 
an email that's also a variable length character up to 128 characters. 
So, this is sort of our schema, this is our contract. 
We're saying these are the only two things we're putting in this table. 
We can't put a thing called age in the table, 
we can't put a thing called favorite beverage in the table and 
we can't put 129 characters in the name column. 
We can put 0 or 1 or 2 or 127 or 128, 
that's just fine, but we can't put 129. 
This is a contract. 
And the database, if we want to put longer characters in, we just say no, no, no, no. 
We want to put 1024 in and then the contract will be we could put up to 1024 and 
if we put 1025, the database would be mad. And like why do you do this? 
Why is it, why is the database so obsessed about this? 
And the answer is, as it lays the data out on this disk drive and 
it wants to get to it fast, 
it really is helpful to know the size, the maximum size. 
Because if you say this is only going to be four, versus four megabytes, 
it might lay the table out differently on the disk. 
You don't need to know that. 
You just need to be explicit about the contract. Okay? 
So this is part of making the data model. 
Figuring out in advance the kind of data that you're going to use, 
how you're going to use that data, and then you communicate that to SQL. 
And then you don't worry about all the magic that makes that super fast. 
So this is the contract that you make so 
that your data is really fast. By being very explicit about your data,
Play video starting at :4:43 and follow transcript4:43
you get in return the database does a lot for you and does it really fast. 
So now I'm going to go into my little SQL window and 
I've pasted in that CREATE TABLE statement.
Play video starting at :4:56 and follow transcript4:56
And different user interfaces will have different things, but 
they all kind of have a window. 
And you all put some database stuff in them, and you hit this execute button. 
It's a this little play button in this one, might be something else in yours, but 
at some point you go, do it!
Play video starting at :5:14 and follow transcript5:14
And down here it says query executed successfully, CREATE TABLE, 
yadda, yadda, yadda. 
So now if we take a look at the data, we see that we have one table and 
the table is named Users and there's name and email. 
If we pull this over we'll see that the VARCHAR is 128, 
so the database knows the contract that we just gave it, okay? 
So that's your first SQL command. 
Your next SQL command is, and you
Play video starting at :5:44 and follow transcript5:44
probably should just copy and paste this stuff off the slides, it's what I'm doing. 
So there's your table, we're going to put some data into it. 
So let's go ahead and do that.
Play video starting at :5:57 and follow transcript5:57
And we can put a new record in there. 
We can say Chuck 
csev@umich.edu. 
We can say another New Record. 
We can say Colleen.
Play video starting at :6:17 and follow transcript6:17
We'll call her vlt@umich.edu. 
I want it so they sort right, edu.
Play video starting at :6:28 and follow transcript6:28
Another record, we'll make this be Sally, 
sally@umich.edu.
Play video starting at :6:38 and follow transcript6:38
And then we'll have another one we'll call like Fred. 
I don't know, Fred. 
fred@umich.edu. 
Now it turns out that everything we're doing is actually running SQL, 
and I want to finish that. 
And if you take a look here at the SQL log, 
you can see all the SQL that's going on right here. 
This INSERT, but let's kind of leave that alone for now, 
we'll just kind of hide that.
Play video starting at :7:4 and follow transcript7:04
But that's what's going on right now. 
And so we made a table and it now has four rows in it.
Play video starting at :7:14 and follow transcript7:14
And now we're going to do some SQL to 
We've done the create and now we're going to do some inserting and deleting and 
retrieving of the data. 
So the first thing we're going to do is insert another record. 
Now, what we were just doing in that user interface was exactly this. 
Here is another example of some SQL where INSERT INTO is 
kind of like a single keyword. 
The name of the table, a parenthesized list of the columns 
and then the word VALUES, that's just part of SQL, and 
then a parenthesized list of the corresponding values. 
So Kristin is the name and kf@umich.edu is the email address. 
And so that is a SQL statement that inserts a new record into our Users table.
Play video starting at :7:56 and follow transcript7:56
So we'll just cheat and grab this, 
copy it, then go to the SQLite browser and we'll go to Execute SQL. 
And I will get rid of the CREATE TABLE because we already did that, and 
just type in insert users with that parentheses. 
It's doing syntax coloring for me which makes it very, very helpful. 
And then I got the right SQL. 
Now let's just say I make a mistake. 
Let's just say I call this ZAP instead of VALUES. 
I will run this and it will go like zap is a syntax error and so 
it does talk to you and then you can go fix that and say VALUES.
Play video starting at :8:32 and follow transcript8:32
And it's actually helping me and I can run that. 
And then it says, success. 
And I go back and look at my data structure. 
I can browse the data, and there's Kristin, right? 
So the INSERT added another row.
Play video starting at :8:47 and follow transcript8:47
Pretty simple stuff, isn't it? 
Okay, so there we go with that.
Play video starting at :8:52 and follow transcript8:52
We inserted another row with Kristin in it.
Play video starting at :8:56 and follow transcript8:56
Now we could delete a row.
Play video starting at :8:58 and follow transcript8:58
And so we say DELETE FROM, which is again kind of like a keyword. 
DELETE, it could be DELETE Users, but 
it's sort of like, we're not actually deleting all the users. 
We're deleting something from the Users. 
And so they add this keyword in SQL that's kind of redundant.
Play video starting at :9:13 and follow transcript9:13
It's not necessary, but it lets us read it a little. DELETE FROM Users. 
Well that sounds like words. 
Sounds nice. 
DELETE FROM Users, the name of the table, 
and then a WHERE clause. 
And you can put WHERE clauses on lots of different SQL statements. 
And that says, don't delete all the rows, only delete where this is true. 
And in this case we put a logical question. 
So this is like a question mark in a if statement, right? 
DELETE FROM Users WHERE email equals ted@umich.edu. 
This could be one row or 
there could be a hundred rows that all have that email address.
Play video starting at :9:47 and follow transcript9:47
That would actually be bad to have a hundred rows that have that email address 
if that were a key, but whatever. 
So this just says DELETE FROM Users WHERE email equals ted@umich.edu. 
So let's do that.
Play video starting at :10: and follow transcript10:00
Again, I just copy this, copy. 
Go back to my SQLite browser. 
I could use the Delete Record button, but 
I'm trying to teach you this SQL language now. 
So this is the way to do it. 
DELETE FROM Users WHERE email equals ted@umich.edu. 
I hit the play button.
Play video starting at :10:17 and follow transcript10:17
And it says executed successfully. 
And I go back, and I look at the data.
Play video starting at :10:22 and follow transcript10:22
And, was there no Ted in there? 
I'd better delete a different one, let's call Fred.
Play video starting at :10:27 and follow transcript10:27
Let's call it fred@umich.edu. 
So now if we do the Browse Data, Fred's gone, so the delete works. 
That's why I do cutting and pasting on this. 
So that's a delete.
Play video starting at :10:39 and follow transcript10:39
Update allows us to sort of reach in to a particular cell or set of cells in 
a table, many rows or many columns or many row / column combinations. 
And we just say UPDATE, which is the SQL keyword, the table name, SET, 
which is an SQL keyword, and then the column name and then the new value.
Play video starting at :11:2 and follow transcript11:02
The WHERE clause is important because without the WHERE clause, 
it would do it for all of the rows, so the WHERE clause reduces the rows. 
So we have a WHERE clause here that says WHERE email='csev@umich.edu'. 
So what we're really saying is go find the rows that have that true and 
change the column name to be Charles. 
Okay? The column name to be Charles.
Play video starting at :11:24 and follow transcript11:24
So let’s do that one.
Play video starting at :11:27 and follow transcript11:27
And hopefully at this point you are sort of following along and 
you're doing your own data because that will be one of your assignments is to make 
a database and turn it in. 
So, I will say execute. 
Oop. and I take a look at Browse Data and you see that Charles is now changed. 
So far so good. 
You see why I really like this language. I mean, it makes so 
much more sense than Python, but don't criticize Python. 
Don't be hating on Python! 
Python is powerful and flexible. 
This is powerful, but not so flexible.
Play video starting at :12:4 and follow transcript12:04
So we did a insert. 
We did a delete. 
We did an update. 
Now we have to do the read.
Play video starting at :12:11 and follow transcript12:11
The R part of CRUD.
Play video starting at :12:13 and follow transcript12:13
And so that is SELECT.
Play video starting at :12:16 and follow transcript12:16
And SELECT takes a list of columns, that's a column list.
Play video starting at :12:21 and follow transcript12:21
And star means all columns. 
FROM is a keyword and then Users is the name of the database. 
And you can have either with or without a WHERE clause. 
And so this says select. 
That really says all rows all columns from the database named Users. 
SELECT * FROM Users. Okay? 
And this says this will turn out to be one row in our little database, 
but it might be more than one if this was true. 
If this WHERE clause was true for more than one, okay? 
So, let's run those commands. 
Now, it turns out that we're kind of implicitly running those commands, 
the SELECT * FROM Users, every time I hit that browse button. 
Whoops, don't do that. 
So if I go over here and when I do browse, 
I couldn actually see that in SQL log, the last thing was that. Okay?
Play video starting at :13:14 and follow transcript13:14
And so it's doing a select on our behalf, but we're learning how to do SQL so 
we don't want to, we want to do it the hard way. 
So we say SELECT * FROM Users.
Play video starting at :13:27 and follow transcript13:27
Hit that, and now down here we see that and 
we also see in this log as the log goes by, that it sent that stuff. 
Now it´s also sending more stuff. 
We´ll get rid of the log, it´s too complex. 
But it´s really just SQL. 
I´m giving you the simple stuff at the beginning, okay? So that was a select and 
I can add a WHERE clause, WHERE email equals csev@umich.edu. 
Let's see if I typed that right. 
And that should show us all the rows, but only show the ones for 
which that's true. 
So that's a WHERE clause, And a SELECT. 
You can also throw another clause on the end of a SELECT. 
You can have an ORDER BY. 
So in this case I'm going to SELECT * FROM Users, which is exactly what I did before. 
Select all the columns from the table Users, 
ORDER BY, again a two-word keyword that rolls off the tongue more naturally. 
email, which is a column. 
Sorting is one of the things that databases do really, really well. 
And that's because it actually sometimes for sorting it has these things. And it has 
these little tricks that say oh that one goes here and this one's the next one. 
And so if you really want it in sorted order, 
have a really quick way to figure that stuff out. 
But that magic, you don't worry about. 
That's the database's problem. 
So you just say hey, smart database from billion-dollar company, 
I would like to order this by email.
Play video starting at :14:45 and follow transcript14:45
I don't know how to do that, I don't even know how to write a sort algorithm. 
I just know that I want it ordered by email. Now do it, database. 
And there you go and you see these things ordered by email and 
if I want to change it to be order by name, it's order by name, okay? 
So name this time, email that time. 
Turns out sometimes you can just click on this header. 
But we're learning the tough way. 
Which is actually not all that tough.
Play video starting at :15:13 and follow transcript15:13
So you can select and you can order them, you can have a WHERE clause and
Play video starting at :15:18 and follow transcript15:18
ultimately, this is the summary of what I've taught you so far.
Play video starting at :15:22 and follow transcript15:22
An INSERT INTO a table with a columns VALUES, 
a DELETE FROM Users WHERE, and a true / false with UPDATE Users SET, 
SELECT * FROM Users, or SELECT * with an ORDER BY.
Play video starting at :15:36 and follow transcript15:36
So at this point, you'd be like, wow, I needed to go to college to learn this?
Play video starting at :15:42 and follow transcript15:42
It's like so easy [LAUGH]. 
It is easy. 
That's why I don't teach you SQL until later, so 
you learn the hard stuff, so you're tough. 
Now I can show you the easy stuff. 
Now, of course there's some complexity to come. 
But at the end of the day when we're talking about a single table and 
the statements that are one table, 
it looks like a really big fast smart spreadsheet. 
And that's why some of you may recognize what you're learning here. 
You may say, you know what, I've actually been doing this! 
And I didn't realize how smart I was! 
I didn't realize I was doing databases.
Play video starting at :16:13 and follow transcript16:13
But we're still just at the basics. 
The power comes with what we're going to talk about next and that's when we have more 
than one table and we start modeling data at the connections between things. 
And that's when we really start to show how you can make things really fast.
Play video starting at :16:30 and follow transcript16:30
When we exploit the relationships between tables. 
So that's what's up next.


Hello and welcome to a Code Walk Through. 
In this bit of code, 
we're talking about emaildb.py. 
This is a beautiful little example in that 
it sort of reduces talking to the database to kind of its pure essence. 
And so we'll start out this code and we import the sqlite3 just to get the library there. 
We make a connection and that, 
in databases, we sort of end up with an open that's two steps. 
That there's the connection to the database which checks access to 
the file and the cursor is kind of like our handle. 
It's not as simple as you just open it and read it, 
but you open it and then you send SQL commands 
the cursor and then you get your responses through that same cursor. 
So cur here is the variable that we're interested in. 
And the first thing that we're going to do, 
is we're going to. we've got this file, 
it will either create this file and right now this file doesn't exist. 
It's going to be in the same directory. 
There's no emaildb so this is actually going to create the file when it runs. 
And then the first thing we're going to do is drop the table if it exists, 
drop table is a bit of SQL. 
If exist just keeps this from blowing up if we start with 
a fresh database and in this case there is 
no file there so we are starting with a fresh database. 
This will accomplish absolutely nothing, 
which is just fine. 
Now we're using triple quotes here. 
I'm just kind of using that to make this a little bit easier to read. 
I could pull those lines up a bit. 
This one's actually small enough that I could, 
maybe I'll just do that. Let's do that. 
Let's bring that baby right up and turn this into a single quote. 
That's short enough, but 
triple code is just this one here's a little longer so I'll use triple quote. 
I'm going to drop table. That's going to do nothing first time through, 
then we're going to do a create table. 
Now sometimes your application will have like a read me or something that says, 
go run these commands to set the database up but we're 
able to just set this database up in this particular application. 
We'll see later ones where we're going to 
leave the database and not start it fresh and in this one, 
we can do the same. 
In this one, we could 
but we're just going to start fresh by dropping the table so we'll create it. 
We're going to have email, an account. 
Basically, what we're doing here is 
we're really going to pretend that this is a dictionary. 
If you recall when I said dictionary, 
a dictionary is like an in-memory database. 
Well, now we're using a database to do 
a database but the first thing we're going to do here is pretend it's a dictionary. 
So these next lines of code, 
hopefully are pretty familiar to you, right? 
You get a file name, loop through it, 
check to see if it's, grab mbox-short 
by default so we can press the enter key, and then loop through it. 
And so this little part right here, 
this is our basic loop that we're doing and so that is pretty normal. 
And if we look at this line right here, 
that line right there makes sure that we can only get the From lines, 
we've done that a bunch of times and we're going to split it. 
We're not going to strip the right because the split is going to take care of that 
and then we're going to grab the email address, which of course, 
in the From line is the second part and then we will have that. 
So now we're going to do some database. 
The first thing we're going to do, 
this bit right here is kind of like the dictionary part. 
So the first thing that we're going to do is we're going to select 
count from our database, that is an integer, 
where email equals. And this part right here bears some explaining. 
This is going to be csev@umich.edu or whatever. 
Now, it is dangerous to put 
those strings, especially from user-entered data, into your SQL. 
You technically could. 
I could make this be a email equals 'csev@umich' 
I would have to escape the quotes and stuff, but this question mark is a placeholder. 
And this is a way to basically make sure that we don't allow SQL injection. 
Go Google SQL injection to get a sense of what that is, 
it's more of an issue in online applications but in this application, 
we're just being good. 
So the way this works is, 
this is a placeholder in this SQL, 
that will ultimately be replaced by this. 
Now you could have several question marks. 
We only have one in here and so you give 
a tuple. And if we just put email, it won't turn into a tuple, 
this is a one-tuple basically, 
this little weird parentheses email comma. 
Parentheses, that is a tuple with 
only one thing in it and that's just the weird Python syntax. 
It's rare that I apologize for Python syntax but that's a little 
bit less than pretty. But it's okay, it's a tuple. 
Normally, if there were like two of these, 
then there would be email name. 
So this cur.execute is actually not really retrieving the data. 
In a way, it's looking at the SQL and making sure that maybe it might verify that 
the table name is right or if there's any syntax errors, etc. 
So this is actually not really reading the data, but we have prepared this cursor, 
This is kind of like the opening of a file but what we're opening is a record set. 
We're opening a set of records that are going to 
be this wherever it is true so it's like we're going to read this like a file. 
Now, later things will loop through this but we're only going to say, 
hey grab that first one, 
We could have even put maybe a limit clause on there or something. 
Grab the first one and give it back in row. And so row is going to be 
the information that we get from the database. 
That is, if there are no records that meet this, 
then row is going to be null. 
So here's kind of again like the get, 
where if the row wasn't there because the way we're doing this, 
is we're going to end up with this row in the database. 
Here is this database and there's going 
to be two columns and there's a bunch of rows and then here's going 
to be see csev 4 and zhen 3 and 
steven 6. So these are accounts and so we're grabbing this variable out 
if it's csev that we're grabbing and that's going to come into here. 
That's going to show up in here and that row 
is a list but we're only getting one thing. 
And what we really are doing is if we search through 
and we got through and there was nothing, then row was None 
means that there was none and we're seeing 
like chen for the first time, we will have to insert it. 
So if row is None, 
we're going to run an insert statement, 
insert into Counts email, count. 
Now, we've got to set it to 1 because it's the first time we've seen it. 
So values and then, again, 
the question mark, the question mark basically says, 
hey I'm going to have a value in this tuple and there's an orderin g to the tuple. 
So there's only one question here. 
One question mark placeholder here and then 1 
is the initial count so email, question mark, 
count 1 away we go and so then again we have 
a tuple that gives to this execute statement, just like in that execute statement, 
the corresponding sort of strings or 
integers that are to be placed by each of the questions. 
So when this runs, there's going to be a new record and there's going to be a 1 
that's put in there into that new record. 
If, on the other hand, we pull back a row that exists, 
we're going to get this 4 number and you might think we want 
to take this 4 number and add it but in databases it's 
always better to do an update 
because there might be 
multiple applications that are talking to this database at the same time. 
So no matter what update does is in a single atomic operation, 
it turns whatever this number is into one higher and we don't have 
to worry about other pieces of code potentially modifying it. 
Now in this case we don't have to worry about that because we're 
the only piece of code but using update to increment 
something is way better than reading 
the value and then doing an update to adding one inside of 
Python and then updating the new value which is that 
two SQL statements but it's also not atomic. 
So if the row exists, 
we just know that it exists and we just want to add one to the number. 
We do have the number sitting here in the row variable but we don't need it. 
And so we're going to say, update count, 
set count equals count plus 1 comma name, 
where email equals and then another 
placeholder and then another tuple for the question mark. Okay? 
So that's what this little bit of code does. 
That is kind of the the read it, parse it, 
check to see if it's there, if it's not, 
insert it, if it is, update it. 
And so then, we see this conn.commit. 
And this conn.commit, basically the way it works is that 
the database is efficiently keeping some of the information in memory and at some point, 
has to write all that stuff out to disk. 
So you can choose at times where you put this commit and right now, 
we're going to commit every time through this loop but you might 
commit every 10th time through the loop because the commit will take 
some time because it forces everything to be written to disk 
and these can run really fast and the commit is the slowest part here. 
So sometimes we do things like commit every 10th record or every 100th record. 
If it's an online system, which is not what this is, 
you have to commit at the end of every sort of screen thing, 
but for this kind of a system 
because we're putting so much in as kind of a bulk insert, 
we might come up with a thing where every one every 10th time we do a commit. 
But ultimately, what this will do, when this is running, 
is it will build up slowly but surely adding new records and then 
1, 1, and then a 2 and 
a 3 and all these things and add another 1, that will be 1. 
It'll do this thing, right? And at the end of the day, 
that is what's going to be in the database. 
So let's take a look at 
what's in the database and now we can actually read the database and so, 
in the database, we're going to run a select and we're going 
to select the email account from counts order by count descending. 
So look at that, isn't that cool? 
We're getting in the top ten because databases are 
good at sorting and they're good at all these other things. 
So we're going to then execute this and then we're going to ask for the rows one at 
a time and the rows are going to be 
a tuple and row sub zero will be email and row sub one will be count. 
So we run all this stuff and then we close the connection and away we go. Okay? 
So let's go ahead and run all this stuff python3 emaildb.py. 
It asks for a filename mbox-short. 
I can hit enter right mbox-short. 
And that's it, and it looks just like that and it counts it and away we go. 
The difference is, at this point, 
we have a file emaildb.sqlite and we can run 
the sqlite browser and we can then open 
this database and we can see what's in there. So here we go. 
It has made an SQLite database. 
We have a table of counts and then we can take a look at the data and there we go. 
We've got the data and we can do this. 
Let me close this. 
It's important at times when you don't want necessarily to have, 
let's see if we can cause it to lock up. 
Let me run this again and it's going to drop this table so I'm going to 
run the code again but this time, 
I am going to do the full one, mbox.txt. 
Now, we'll see what happens here. 
But it ran so what we have to do then to see this data, 
this is from the previous run but if we wanted the most recent one, 
we hit refresh and then away we go and so we can see this stuff. 
And so this is just a real simple start to see 
how you can connect some of the stuff that we've 
been doing but store the data in a database, 
but the nice thing about the database is that 
it can store this stuff from run to run even though, 
in this case we're dropping the table every time. 
In later things, we will see how we can store data from run to run 
to give ourselves more restartable processes. Cheers.

Our First Database
In this assignment, you will use the SQLite browser to make a database, insert some data and then run query.
________________________________________
This course uses a third-party app, Our First Database, to enhance your learning experience. The app will reference basic information like your name, email, and Coursera ID.
Counting Email in a Database
Count messages from organizations
________________________________________
This course uses a third-party app, Counting Email in a Database, to enhance your learning experience. The app will reference basic information like your name, email, and Coursera ID.
Coursera Honor Code  Learn more
 
I, elham fazel, understand that submitting work that isn’t my own may result in permanent failure of this course or deactivation of my Coursera account.
Hi, Chuck here. 
I'm in Zagreb, Croatia. 
And here we are at another instance of an Office Hours. 
The extended edition. 
Tell us your name. 
>> Hi, I'm Marco.
Play video starting at ::12 and follow transcript0:12
>> Tell me what are you doing in education right now? 
What degree are you pursuing? 
>> I'm studying faculty of electrical engineering and 
computing at University of Zagreb, and I am graduate student. 
>> And so how many Coursera classes have you taken? 
>> I've taken two courses, yours and Introduction to Python. 
>> Why do you use Coursera? 
Why do you add in Coursera to you education? 
>> Because first of all I want to broaden my knowledge. 
>> And after all, some, how 
do you say? 
To show something in my CV that I 
have taken other courses than studying at a faculty. 
>> Do you have any suggestions for improvements? 
Or what would you say if you were talking to the people who ran Coursera?
Play video starting at :1:3 and follow transcript1:03
>> Just make it faster. 
>> Make it faster? 
>> Yeah. 
>> Okay. 
So, tell me your name. 
>> My name is Anamaria Cudanar. 
I'm student of philosophy and 
social humanistic informatics, graduate and undergraduate.
Play video starting at :1:20 and follow transcript1:20
What was the question? 
[LAUGH] >> So 
tell me about how many Coursera courses have you taken? 
>> I've taken four, Guide to Irrational Behavior,
Play video starting at :1:35 and follow transcript1:35
How to reason and argue, and human computer interaction. 
And the fourth one was artificial intelligence at Stanford. 
>> Did you finish them all? 
>> No, I finished only one. 
And I got a certificate from how to reason and argue. 
So how do you fit it in with the rest of your education, I mean how does it fit, 
and what part of your education does Coursera fulfill? 
>> The things that I learned are outside of my study scope, 
I'm really interesting in a lot of things and I think that people should be 
more prone to interdisciplinary, >> So I want to learn things from other 
places, and I think that makes me more valuable at the market, 
and I'm really genuinely interested in a lot of things. 
>> So is there anything that worries you about Coursera, does it bother you, or 
do you have some fears about the future? 
Or do you think it's like >> Fears? 
I fear that it will become, when money gets involved, 
it will no longer probably able to be open-source because somebody has to pay 
it, and I think it's only a matter of time when it 
will get, somebody will have to pay for it. 
So, I'm afraid that it will no longer be available to a lot of people. 
>> Okay. Do you have anything you would say, 
to suggest to improve it? 
That you're a professional and sort of learning technology. 
Do you have any suggestions? 
>> Just make it fun. 
Like you or Don already does. 
>> Okay. 
>> Okay, so. 
>> So there you have it, the voice of the student from downtown Zagreb, 
and we'll talk to you next time.
And they were part of the coming, going from wild. 
And then we realized that, hey, I want to buy a product. 
What kind of a feature do I need? 
Another one of the things that I have done is the feature analysis. 
So we have about half a dozen of product. 
And the standardization are really building a consensus. 
We brought from a matured technology 
that are ready to be standardized where people say, 
do I buy IBM or do I buy Oracle, or shall I buy a cheaper one? 
This kind of a decision started emerging. 
And selection of, I mean, how many variety 
of application you can build on top of a software foundation, 
what I call a database management system, is too varied. 
And so you want to have some sort of a standard so 
that your application can work on different platform.
Play video starting at :1:54 and follow transcript1:54
We work with files, and we call it the file system. 
The files are hierarchical, they were in the IMS,
Play video starting at :2:2 and follow transcript2:02
the IBM information management system, which is a tree structure. 
And the debate was going on whether there should be a tree or 
a network or a flat file. 
And we are still debating whether the data have a 
self-describing tag, and later on, we known it as a metadata. 
And now, people call it the schema. 
So the Database System Study Group come up with a reference model or a 
specification for a minimal functionality of a database management system. 
In order to be a database management system, you want to be able to store data, 
retrieve data, modify data, organize data, 
delete, manipulate data, and it becomes a spec.
Play video starting at :2:59 and follow transcript2:59
And during that time there was a birth of a, 
we initiated a birth of a ANSI group. 
It's now called INCITS, the ANSI American national standards group. 
And it's called the X3H2 of which Don Deutsch and 
people like Len Gallagher all participated in that. 
That group is called the data management language.
Play video starting at :3:32 and follow transcript3:32
In order to standardize anything, you
Play video starting at :3:36 and follow transcript3:36
realize that you can have a lot of light bulbs, for example. 
You can have red light bulb, white light bulb. 
The only thing you want to standardize is when you want to talk to another person. 
Communication, interface, or a 
area where both of us have to understand a common vocabulary, or whatever. 
So the standard, the only standardization 
of a software system is not the capability but a language.
Play video starting at :4:18 and follow transcript4:18
And relational database at that time was IBM, 
Chris Date, and he's talking about normalization. 
He started talking about flat file and 
he called it a table, and it's a very easy concept that everybody understand. 
So in order to retrieve a table, you say 
select from a column such and such, from a table of employee, 
and there was a birth of a simple query language.
Play video starting at :4:56 and follow transcript4:56
Testing part is also very important aspect of when you adopt a standard. 
You want to certify that the product conform to such and 
such version of ISO standard, or JTC 1, whatever it is. 
So that gets to be if your, otherwise your app won't work. 
Your application, let's say you build a student course record. 
And no matter, you got Oracle, you got a 
Xybase or Microsoft SQL, you want your application to work no matter what.
Play video starting at :5:40 and follow transcript5:40
And that's what the marketplace wanted to go, the user. 
Of course Oracle, or Microsoft, buy my product, Oracle would say buy my product. 
And in the procurement, you say, 
I want to be compliant with SQL. 
And so you have to have the conformance testing certificate. 
And we have the NVLAP, it's a laboratory that's certified and 
gives you a validated product list. 
Here is the list of product that have been validated that they conformed to it. 
And you can buy from that list, but there is a requirement. 
This is strictly user. 
You're buying, because you're paying the money, not us.
Play video starting at :6:33 and follow transcript6:33
Timing is everything.
Play video starting at :6:36 and follow transcript6:36
You can't standardize a thing too early, 
or you drive a lot of innovative concept away. 
Because people say, hey, there's no way for 
me to get into your market, because you already decided. 
And even though it's not very good, I won't get into that business. 
So, you killed innovation. 
And if it is too late, you missed the opportunity, 
you get too many variety of things coming up, and the choice is too much. 
But, of course, SQL is one of the success stories that we have. 
[MUSIC]
Hello everybody, and welcome to Python for Everybody. 
We're going to do some code walk-through. 
If you want to follow through with the code, 
you can download the sample code from Python for Everybody. 
So, the code that we're going to play with is 
the Twitter spider code that is both talking 
to the Twitter API and talking to the database. 
So, what we're going to be doing is we are going to run 
code that's going to hit the Twitter API much like we did in a previous chapter, 
and we're going to retrieve the data, 
but we're going to remember the data. 
So, we don't have to retrieve it again. 
So, we're going to keep track of people's friends. 
What we're doing here is illicitly pulling down slowly, 
but surely based subject to our rate limit. 
We're pulling down who our friends are. 
So, let's take a look. We're going to use urllib and urllib.error, 
the Twitter_URL, which was code that augments my url to do all the OAuth calculation. 
We're going to get json data back. 
We're going to make a database and we have to import SQL because of 
the way Python doesn't trust any certificates no matter how good they are. 
So, this is our URL to talk to the Twitter API. 
We're going to make a database. 
Again, the way SQLite works is as if this spider.sqlite doesn't exist, it creates it. 
We get ourselves a cursor and we're going to do a create table, 
this if not exists some SQLs, 
but sqlite3 does this. 
Create table if it doesn't exist. 
We want to start this over and over unlike the tracks example. 
I want to start this over and over, 
and not lose data. 
This is a spidering process and we'll see a lot of these. 
We want a restartable process where we use a database. 
So, if we're starting with nothing and there's no file, 
spider.sqlite, it creates this table. 
It's the name of the person whether we retrieved or not 
and how many friends this person has that we know of in our database. 
Now, this little bit is to deal with the SSL certificate errors. 
The certificates are totally fine, 
but Python doesn't trust any certificates by default, 
which is frustrating, but whatever. 
So here, we're going to have a loop. 
We're going to ask for Twitter account. 
We have to type quit to quit. 
If we hit Enter in this case, 
we're going to actually read from the database on 
unretrieved Twitter person and then grab all that person's friends. 
9Okay. So then, if we're going to do a fetchone, 
get one, and that's going to get the name of the first person, 
the sub zero, if we add more things than name here, 
sub zero was the first of those. 
Fetchone means get one row from the database and 
sub zero means the first column of that first row. 
If this fails, then we retrieved all the Twitter accounts. 
So, we're going to augment this Twitter_URL using this mix. 
You can look at the twurl.py code. 
This basically requires the hidden.py file, 
which has your keys and secrets in it. 
You've got to get hidden.py updated. 
I've got it updated, but I'm not going to show you 
because it has my keys and secrets in it. 
So, we're only going to take the first five, 
which means we're not going to find friends of friends of friends. 
It's only at most five recent ones. 
We could run this with a much higher number, 
so we have more than one friend. 
We'll show the URL while we retrieve it. 
We will do our URL open. 
We'll do a read, and then we'll do a decode to make sure that this UTF, 
this will give us data in UTF eight, 
and then decode will give us data in unicode, 
which is what we need inside of Python. 
We will ask for the headers from the connection. 
We'll say, "Give me the headers. 
Give me a dictionary of the headers." 
The x-rate-limit-remaining header from the Twitter API tells us 
when we're going to be told we can't use 
this API anymore because this is one of those things, 
and then we're going to parse, and load the data that we got from Twitter, 
and get a, I think it's a list. 
Yes, it's a list, and then we could dump this if you want in here as you can undo that. 
Then, what we're going to do is we just 
retrieved this person screen name and their friends. 
So, the first thing we want to do is update 
the database and change the retrieved from zero to one. 
That's because we're going to use this to know about unretrieved. 
So, retrieved being one means we've already retrieved it and we did retrieve it. 
So, for that account, we've retrieved it. 
Then, what we're going to do is we're going to parse that. 
So, this is similar to the Twitter code we did previously in the web services chapter. 
We're going to go through all the users. 
We're going to find their screen name. 
We're going to print the screen name out, okay? 
Then, what we're going to do is see if, let's see, 
so we're going through all the users who are the friends of this person, 
and we're going to say, "Okay. 
Let's select the friends from Twitter where the name is the friend person."
Play video starting at :5:20 and follow transcript5:20
What we're going to do is if we're going to do a cur.fetchone of this Twitter, 
the name of the friends, 
this is the friend's screen name, 
so we're going to say, "Okay. 
If we get this, 
we're going to get that friend's screen name and we're going to get 
how many friends this particular screen name has. 
If we find a URL, 
if we find it in there, 
we're going to do an update statement, 
and add one to their friend count, 
how many friends they have, 
and then keep track." 
This count here is not in the database. 
It's just so I can print it out at the end. 
If there is no record for this particular friend, 
we're going to insert them into a new, 
and we're going to say, "Here's the new person that we just saw." 
That's their name. We're going to set retrieved to 
zero and we're going to say that they have one friend.
Play video starting at :6:17 and follow transcript6:17
We're going to commit the transaction and then we're going to close this at the end. 
So, let's go ahead and run this. 
The first time it's going to create an empty database. 
So, I'm going to say, python3 twspider. 
So, ls *sqlite, nothing there. 
Python3, oops, that's because I removed it. 
Python3 twspider.py. 
Okay. So, I'm going to start with a Twitter account, drchuck. 
So, it's doing this retrieval. Don't worry. 
Showing the token and the signature is not 
dangerous because you don't want the keys or the token, 
the secrets and the token secrets. 
So, don't get all too worried. 
So, I have 11 calls left. 
So, I got to hope this all works. 
One of my friends is Stephanie Teasley. 
I do these in reverse order. 
So, let's grab Stephanie and ask for Stephanie's friends. 
So now, we just retrieved Stephanie's friends. 
Here are Stephanie's most recent friends, 
and then I can just hit Enter, 
and it will randomly pick. 
Let's see if I can in the database. 
Let's open this up, File, Open Database. 
Hope I don't lock myself. 
Sometimes it's a little scary when you look at the database and you're just checking. 
So, this is what my database looks like. 
We retrieved Stephanie and she has, 
this is how many people. 
So, these are the friends of Stephanie and me. 
I'm not in there. So, we've retrieved Stephanie, which was a friend. 
So, let's go grab, I don't know. 
Let's grab Tim McKay and get that one. 
Remaining 10. I don't have too many of these, Tim McKay. 
So, there we go. 
Remaining nine. 
So, if I do a refresh on this, 
then you see I've got some more folks. 
If I hit Enter here, 
it'll pick one randomly based on the retrieved being zero. 
So, it won't pick Stephanie or Tim because there's zero, 
but we have lots of other folks to pick randomly. 
We'll hit Enter. Who did it pick? 
It picked screen named liveedutv, 
which is ironic because I'm recording this on LiveEdu.tv right now. 
So, we can keep hitting refresh in the way we go. 
So, I'm going to stop now because I only have eight remaining. 
So, I'm going to type quit. 
So, we'll see how that works. 
So that's how it works. 
Now, remember that you've got to edit the 
hidden.py file to make this work because we are talking to the Twitter API. 
If you don't edit that file, it won't work for you. 
So, I hope you find this useful. Cheers.
So now we move from sort of the SQL and the contracts we need to talk to a single 
table, to linking multiple tables together, 
and this is where the real power comes, and this is where the complexity comes. 
So up until now, it should be real simple.
Play video starting at ::25 and follow transcript0:25
When you start a company, we're going to kinda pretend we're going to start a small 
company to build an application to manage music.
Play video starting at ::32 and follow transcript0:32
When you start a company, 
you're going to build an application, lots of applications need databases.
Play video starting at ::38 and follow transcript0:38
And you need to design the database for your application.
Play video starting at ::43 and follow transcript0:43
And often this is very much a team effort with a lot of different 
people with skills. 
Some people worry about the user, end user capabilities, 
some people worry about the performance, etc. 
And so database design, what I'll show you coming 
here is just the beginnings of database design, but the basics are very powerful. 
And it's something where smart people should take time in database design. 
And so it's a very collaborative process 
and if you ultimately look at the database design for applications, 
we draw these crazy pictures, right? 
And in these crazy pictures we are capturing, 
this is basically multiple tables. 
Table, table, table, table, 
and this particular database is kind of about an events, 
like, you know, reserving the picnic shelter at a park, right? 
What times, who's going to be there, who reserved it? 
All these other things. 
And what we're starting to show is that how these tables are connected together. 
So each of these little arrows, so this is a table, and 
these are the columns in the table, and then some of the columns are special 
columns that represent relationships with other tables. 
And we're not going to go into all the detail, you can eventually go into some of the detail 
where you see what this little arrow means and that means one and 
this means many etc., etc.. 
And this there's all this fancy stuff and so we'll talk about this eventually. 
But this is sort of like what we're going for, we're going for 
a picture of how we want our application's data to be stored in the database. 
And this then becomes our schema and it's the contract.
Play video starting at :2:22 and follow transcript2:22
So, we made one thing with two, we made one table with two columns, and 
that was a schema and a contract, but 
now we're going to make multiple tables with many columns and 
some columns that are specifically there to connect from one to another. 
So if you're working in a large application, you might walk in and 
see a picture like this on the wall.
Play video starting at :2:44 and follow transcript2:44
And you take a look, whoa, that's really important, that must be really complex!
Play video starting at :2:50 and follow transcript2:50
And it, for this application, it probably represents 
years of clever engineering to make sure that the application runs well. 
But this is basically how this, I don't know what it is, 
open mecker medical records system, I just kind of borrowed the picture.
Play video starting at :3:5 and follow transcript3:05
This is how the data is stored in its database. 
And these things can be very complex and 
the project I work on called Sakai, it's probably four times bigger than this. 
But if you zoom in on it, which you can't, but it's just a table and 
some columns and some connections. 
And then, oh yeah, there's a table, well that one's kind of complex. 
Here's a table, some columns, and two connections. 
So, yes, it looks complex on the surface, but 
ultimately we're just trying to figure out which tables we are going to make, what we're 
going to put in those tables, and then how we're going to connect the tables together. 
And the connections are the thing that make these things so powerful. 
We could just put all these data in one file, but 
then this thing would run like terribly slow. 
And so the trade-off of thinking through how your data is going to look 
is that when you're done, it's fast.
Play video starting at :4: and follow transcript4:00
A lot of times we don't worry too much about how fast your program's going to run. 
But when it comes to scanning data, 
especially if it's a lot of data, you think about that a lot.
Play video starting at :4:10 and follow transcript4:10
So the whole idea is to figure out the data that you need to represent, 
and then drawing a picture, and then lines between those pictures, right? 
And the basic rule that we're going to use is 
don't put the same string data in twice. 
So for example, if we have a column of something, don't put Chuck in twice. 
So that's bad. 
So if you have some column and you're replicating the same string data twice, 
that's not good. 
What you want to do is you want to make another table and 
put a Chuck over here and give a number to Chuck like 1. 
And then put 1, 1, so to indicate that something belongs to Chuck, 
which means you're modeling data at a connection between one table and another. 
We'll go through this in super great detail. 
So the basic rule is don't put the same string data in twice, 
use a relationship instead. 
And the other thing is sort of like model the real world. 
If you have users and tracks and Christmas tree farms and whatever, 
you'll have a table for the Christmas tree farms and you'll have another table for 
the Christmas tree types and you'll have another table for whatever. 
And so often you're starting to sort of build an application and 
so the application that our little company is going to build is an application 
keeping track of audio. 
Our company has decided that people don't use albums anymore and 
aren't interested in buying whole CDs of music. 
So we're going to sell music by the track. I think this is a great idea, 
and I think we're all going to get rich with this little company. 
And this is the user interface that I invented, or 
I screenshotted from another vendor's. 
But, whatever this is, we are going to this is the program we're going to build. 
We're going to make a track-making thing. 
Now, just looking at this user interface we see some problems right away. 
And often, if you just try to turn this into a spreadsheet, 
these things would become the problem. 
And the problem has to do with replicated data in columns. 
And so, it's like great, this is all cool, 
until you have the same artist name in the columns. 
That could be once or hundreds, because Black Sabbath has written hundreds and 
hundreds of tracks, and then even in the album column, that's a problem. 
And then it gets even worse when you're in the genre column, 
you're putting the string in a zillion times. 
And if you've been writing Python programs they kind of finish really fast, and 
that's because the only assignments I've given you are tiny. 
But when you're going to do a million or 
a trillion things, the difference between metal and the number 2, 2, 
2, 2, 2, to replicate this is actually very significant. 
Because this isn't just a six, or five character string, this could be a very 
long string, and so in your data you have to allow for very long strings. 
And so these are the problems right there, all this replication. 
Now it turns out that we have a user interface person in the room, 
and the user interface person we say like, hi, we're a database expert. 
We took a class online and we know that you're not supposed to replicate data and 
the user interface person says, oh no. 
This replicated data, we've done surveys and 
that's exactly what the user wants to see.
Play video starting at :7:31 and follow transcript7:31
And you can't argue with that. 
If that's what the user wants to see, that's what they see.
Play video starting at :7:36 and follow transcript7:36
But we still have to write an efficient application. 
And so that's where we start going through a data modeling exercise. 
Where we say, this is the kind of stuff we want to represent, and this is the kind of 
user interface we want to support, how can we build a really good data model? 
So it's not like you've got to change the user interface to make it good, 
you change the data model then to represent the stuff we want, and 
then construct it in a way that the user interface is exactly what the user wants.
Play video starting at :8:4 and follow transcript8:04
So the idea is you look at the data that your application is going to look, 
and we've got all these columns, and 
you say is this column represent a thing in the real world? 
Or is it just another attribute of a thing? 
So there's like a thing and then attributes of the thing, or two things. 
And so you've got to go across all of the columns, and so that's what we're going to 
do, we are going to look at all the columns and we are arguing. 
So right now imagine we're in a conference room, we're sitting around a table. 
And we're going to draw this picture, and this picture looks like the thing, 
it's got little boxes and lines, right? 
We're going to draw a boxes and 
lines picture, and we have a blank screen right now. 
So the first question, actually, in these meetings is commonly where to start. 
Because you've got a lot of stuff. In our example, it's really simple. 
And it turns out that it's not so critical where you start. 
Even if you start at the wrong place, eventually you're just going to have this web 
of information, and it's all connected, and it'll all work out if you do it right. 
But it does simplify the drawing of your picture if you start at the right place. 
And so, the way I was taught, to start at the right place, was to think about 
the thing that is the most essential to this application. 
What is the one-sentence description of this application? 
And in this application, it's a thing that manages tracks. 
It's not an album-managing thing, it's not a artist-managing thing, or 
a genre-managing thing, it's a track-managing thing. 
And we kind of see that in our user interface. 
We see that every line is a track. And so that makes it easy. 
The first table we're going to build is the track table. 
And once we build the track table, then we have to look at all the other things and 
say, look, which of these things are themselves tables, 
and which of these things are just attributes of track. 
Okay? And so it turns out that things like numbers, and 
like star is just a number, that's five, these are all fives, 
apparently I only like stuff or hate it, and then this is the number of plays. 
And so you go like oh, that's part of it, that's part of a track, 
that's part of a track. 
Well, and now we come to the three things that aren't part of tracks because they have 
the replicated data, that's the red flag that says uh-uh, not part of a track. 
So, somebody gets up to the board, grabs a piece of white board and they go like that's 
our first table, it's a track table and its going to have a rating, length, and a count. 
I guess there should be a title in there as well for this column here, so 
we have a title field, title. 
Okay, so now we're good, right? We've got that, right, we've got that. 
The question is, what's connected to that?
Play video starting at :10:43 and follow transcript10:43
Right? Well,what is the thing that's the next thing to draw? 
Well, tracks could be connected to artists, they could be connected 
to albums, so let's just say, kind of albums have many tracks. 
So, the next thing we're going to do is we're going to make an album table. 
And we're going to say on our white board, we're just drawing on a board right now, 
we're not writing code yet. 
That tracks belong to albums and now it's kind of easy that what albums belong to, 
well albums belong to like groups. 
Now if you're a music expert you kind of understand that we're oversimplifying 
things, and that's a fine argument to have when you're starting your company, 
but we're going to pretend the world is simple, and that tracks belong to albums, 
that belong to artists. 
So we're almost done with our meeting. 
So we got artists, albums, and tracks, 
and we've drawn a picture. 
And the question is, where does genre belong to? 
What does genre connect to? 
Does genre connect to an album? 
Does genre connect to an artist? 
Or does genre connect to a track?
Play video starting at :11:48 and follow transcript11:48
Now you might want to go to your iTunes and go to a track and change its genre.
Play video starting at :11:55 and follow transcript11:55
Change it to easy listening.
Play video starting at :11:59 and follow transcript11:59
Now if the track was, I mean if the genre was connected to the artist, 
I mean this is a album, sorry. 
It means that it would then immediately change all those to easy listening 
because that means that albums have an attribute of what their genre is. 
If it was the same for 
an artist, that means that all your AC/DC would be changed to easy listening. 
And if it was an attribute of track, 
only this one would be changed to easy listening. 
So the question is, when you go into that system and you change one thing,
Play video starting at :12:32 and follow transcript12:32
does it change all of these based on the album or the artist? 
Well, you can pause and go ahead and do that but, 
I'm going to tell you, it turns out if you change that it only changes one. 
So that actually tells you, in the meeting we're arguing about this. 
I think it should be here, and I think it should be here. 
And then you say well but 
if you do it this way, that means that it's going to change. 
Then the UI person is like no, no, no, 
we can't have it connect to the album because then our users will be so 
mad at us and blah blah blah blah blah, and we wouldn't make a lot of money. 
So when it's all said and done, you've argued through. 
It took you a lot longer to argue this last bit, this was the hard part, 
to say okay, genre belongs to track, it just does. 
And this is a simple, trivial, 
example of how the data model creates the features of the application. 
So that when we started we saw this big picture, 
that what's in the data model determines what the application is capable of doing.
Play video starting at :13:31 and follow transcript13:31
And we have to get the data model right, so that it can all be very efficient. 
So now that we've drawn this picture on the wall in our conference room, 
at some point we have to map this into a database, into a database structure. 
Okay? We're going to figure out how to actually map that 
logical picture that we just drew into a physical picture 
exactly how we're going to represent this in a database.
So welcome back to lunch, right? If you remember the morning the last lecture we 
argued, we drank a bunch of coffee, we scribbled on white boards, 
we erased white boards, and we argued about where the genre belonged. 
But when we were all said and 
done we ended up with this picture its still on the white board and 
we're coming back from lunch now. 
This is now how databases represent data. We have to be a little more explicit. There's 
no like belongs to magic in databases but when you're building your data model you 
don't want to be thinking explicitly too much about the database. You turn this 
"logical" model into what we call a physical model, by mapping it into the database. 
So, what we do is we just take each of the tables, and the relationships between 
the tables, and we have to augment them with little bits of information. 
And so, here's the track table, and so we'll make a table called Track. 
And we take like title, rating, length, and count, and 
they become just columns in the table. That's the data we have to represent. 
And then we tend to add things to it. 
And so we're going to add what we call a primary key. 
And a primary key is a way 
for us to refer to a particular row, and so it's a unique number like 1, 2, 3, 4. 
So each album is going to end up with a number. 
We'll put insert the title and the title will get a number. 
Right? 
And then we use that number in a column of a different table to sort of point to it. 
So these primary keys are the endpoints that we're pointing to. 
So that we can create an arrow to a particular album, 
we've got to add a id to it. 
So we add a primary key.
Play video starting at :1:49 and follow transcript1:49
And then the other thing we do is we have to add the columns that are the other end 
of the arrow, the starting point of the arrow. 
And so I'm by convention, in this particular model, I'm naming primary keys all id. 
In track you've got to think all id and then album_id is sort of the starting point. 
So album is the name of a table, followed by underscore, followed by id. 
Now, there's no rules about how you name these things. 
These could be named X and Y if you wanted to but, 
as we've learned in programming Python, and other programming languages, 
making sensible names really reduces the cognitive load of understanding what 
the heck you meant when you were creating this. 
So we create a convention, a naming convention. 
And, the, we have terminology for each of these things. 
A primary key is the key for which there's one key for every row. 
It's used as the way to point to that row in other tables. 
The foreign key is one of these columns that we add 
to be the starting point of the arrows. 
The primary key's the ending point of the arrow and 
the foreign key is the starting point of the arrow. 
The only other thing that we do is we may or 
may not designate one of the columns, sometimes more than one, 
as what's called the logical key. 
The logical key is that 
unique thing that we might use to look up this row from the outside world. 
In this case, the album title might be a way we'd look it up. 
Like, oh, where is Led Zeppelin IV. 
Type in IV and it'll search it. 
So Led Zeppelin IV is going to be the title. 
Now all we are doing is saying, 
hey database, we're not looking these folks up by rating or length or count. 
But we might be looking tracks up by title. 
So, somehow on your storage 
maybe you leave some shortcuts to get to this more efficiently or more effectively. 
So the logical key is really our way of saying we might use this 
in a WHERE clause.
Play video starting at :3:46 and follow transcript3:46
We might use it in a WHERE clause, help me out out here. 
We might use it in a WHERE clause.
Play video starting at :3:51 and follow transcript3:51
And it also sometimes, it's like we also might use it in an ORDER BY clause or 
a WHERE clause. 
And so that's the logical keys. 
So we have these three things, primary keys, logical keys, and foreign keys. 
And so if we keep drawing these pictures it starts looking complex but 
then it turns out really simple. 
If we take the whole data model and sort of add these primary keys, 
logical keys, and foreign keys to model the beginnings and ends, 
the beginning and end of arrow, beginning and end of arrows, beginning 
and ending of arrows, we have to stick primary keys in all the tables.
Play video starting at :4:23 and follow transcript4:23
We stick foreign keys in those tables that have starting points.
Play video starting at :4:28 and follow transcript4:28
And then we indicate that certain things are our logical keys. 
It looks kind of complex, but once you've drawn the picture, 
and you have the naming convention for what you're going to name these things, 
it's a surprisingly manual task. 
The mapping from the logical to the physical 
is beautifully simple as long as you have a naming convention. 
Now, if you walk into an organization and you took this class and you say like 
Dr. Chuck's naming convention is awesome. 
As a matter of fact, 
I stole this naming convention from a thing called Ruby on Rails. 
The name of the id, the artist_id. 
It's a good naming convention.
Play video starting at :5:3 and follow transcript5:03
And naming conventions are kind of like artistic. 
Some you think are prettier or not prettier, but any naming convention works. 
And you walk in and you go like oh, I took this class and 
I learned this naming convention of id and table_id and they'll say well 
we don't use that, we use this thing where we start with a lowercase i and the we 
uppercase the iTrackID, that that would be their primary key for 
a track, or maybe they call it pTrack Id for primary key, right? 
So that would be the name of this thing and you're in this company and you're like whoa. 
pTrackId, that looks like crap. it's a terrible, stupid idea. Well, don't do that. 
I mean, this is not a superior naming convention to this other one, 
however they do this other one, right? 
What's important is that there is a naming convention, and when you work for 
a company. just learn their naming convention, and 
don't complain about their naming convention, unless you get to know them or 
maybe you're sort of out for coffee or something later and you're like, 
well, how come you guys never did the cool Ruby on Rails naming convention? 
I took a class and it was pretty cool as long as you're nice and you don't threaten 
them and don't tell them how dumb they are by choosing the wrong naming convention. 
So now what we're going to do is we're going to turn this into a new table.
Play video starting at :6:18 and follow transcript6:18
Okay, and so I'm going to use the wizard to make new table in our little database. 
Let's go over to, we're still in our database.
Play video starting at :6:29 and follow transcript6:29
And I am going to go to Database Structure.
Play video starting at :6:32 and follow transcript6:32
Where's the new table button? 
New table, new table.
Play video starting at :6:36 and follow transcript6:36
File.
Play video starting at :6:37 and follow transcript6:37
New table, create table. 
There we go. Edit, create table.
Play video starting at :6:42 and follow transcript6:42
Okay, so we are going to create a table, and I need to kind of look at 
I'm looking for my cheat sheet. We'll start with the Artist table.
Play video starting at :6:53 and follow transcript6:53
The Artist table, and we're going to add a field to it and 
we are going to name the first field an id field, and it's going to be a number. 
We are going to say that it's not null, it's a primary key. 
We're telling it that we're going to use this a lot and 
if we're linking into this table, that means we're using it a lot.
Play video starting at :7:15 and follow transcript7:15
Auto increment, it means we as the programmer 
don't actually have to specify this value, it's going to be automatically specified. 
Because pretty much 1, 2, 3, 4, 5 are the values that we're going to use. 
And then unsigned is whether it's positive or negative. 
And for this one I'm going to leave that off. 
The other thing that's in this in our little table, let's go back and 
look at our little picture, is the name.
Play video starting at :7:40 and follow transcript7:40
Add another field and we'll name that name. Oops. 
Lowercase name. 
And we will make that a text field.
Play video starting at :7:50 and follow transcript7:50
And in this case we're not going to give it a length. 
And, there's a way later we'll give other ones lengths. 
And then we are going to hit the OK button.
Play video starting at :8: and follow transcript8:00
And when it's all said and done we have an Artist table, okay? 
This is our old Users table, this is our Artist table. 
We could make a whole new database if we wanted, but 
we're not going to, we're just going to put all these things in. 
Actually, let's just get rid of this table. 
Get rid of Users. Edit, Delete Table.
Play video starting at :8:16 and follow transcript8:16
Good bye User table. 
That was from the previous lecture. 
So now we have an Artist table. 
Okay? So that's the wizard way of creating a table.
Play video starting at :8:26 and follow transcript8:26
The next table we're going to create is the Genre table. 
Now the idea is we tend to work from outward in. 
The leaves of this tree outward in. 
So we created the Artist table then we'll create the Genre table, 
then we'll create the Album table. 
And then we'll create the Track table because you kind of want to create 
the ends of the arrows before you create the beginnings of the arrows, okay?
Play video starting at :8:45 and follow transcript8:45
So we'll create the Genre, and 
now I'm just going to use to SQL because that's a lot quicker for me to type. 
Here's the CREATE TABLE, we're going to say that this guy is an INTEGER, 
it's NOT NULL, it's got a PRIMARY KEY and it's AUTOINCREMENT, and it's UNIQUE. 
And that is our way of saying 
give each row a little number.
Play video starting at :9:2 and follow transcript9:02
So we go to Execute SQL and I put this thing in here. 
And then I run it. 
It worked and if I take a look at our Browse Data or 
our Database Structure, Genre is in there and Genre has two columns, 
id and name. And then we have the other tables. 
So now we're going to create the Album table. 
Now the thing that's different about the Album table 
is that the Album table is our first example of a foreign key. 
So this is our foreign key. 
We've been putting primary keys in every table. 
Primary key pretty much say this over and 
over and over again, this long INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE. 
Just say that over and over and over again. 
Now, we're going to have a foreign key which is the start, 
the foreign key, primary key.
Play video starting at :9:50 and follow transcript9:50
Right? And so, we're just going to call that an integer. 
In other databases you can add some stuff to it, talk about 
what to do with the parent thing, but we're not going to do that for now. 
We're just going to say that's an integer, that's a starting point of an arrow. 
And we're naming it artist_id just to jog our memory 
that that's what's going on there. 
Put SQL, paste it, run it, poof she works. 
Database Structure. Now we got Genre, and let's look at the last one. 
Okay? So the last one is the track. 
Okay? So CREATE TABLE, the name of the table. 
We've got this sort of thing that by now we're cut and paste a bunch of times. 
We have a primary key, we have a logical key. 
It just happens to be green, it's TEXT. 
And then we have two foreign keys. 
Because if you remember, there were two arrows coming out of Track.
Play video starting at :10:42 and follow transcript10:42
Both to Album and to Genre. 
So remember, oh, Album. 
album_id, genre_id. 
Naming convention is your friend. 
And then we just have some stuff that's integers like the length, 
the rating, and the count. 
Then we put those in. 
So now we have the columns and the rows and all the foreign keys for Track. 
And then we will run that. 
And if we take a look at the data we will see 
we got all of them done. Album is now complex. 
And all these things.
Play video starting at :11:24 and follow transcript11:24
Wait a sec, did I not? 
What did I get wrong here? 
Oh, no, Track is the complex one. 
So Track has a bunch of stuff. 
So there we go. So if we take a look at, we've got all of these things, and 
we have translated our logical model into a physical model, and 
we translated the physical model into a series of CREATE statements. 
And we've run those CREATE statements, and 
now we've represented the various kinds of tables that we want to insert data into. 
So we're going to stop here. 
But next we're going to start inserting data into these tables.
So before lunch we developed a logical model, 
after lunch we developed a physical model.
Play video starting at ::16 and follow transcript0:16
And sort of implemented it in the database and then we went home for the night. 
And now it's the next morning and it's time to insert some data into our tables. 
Now, you've got to remember all the keys and fields and stuff like that.
Play video starting at ::28 and follow transcript0:28
Just like we're inserting data from kind of like the outward simple things 
to the more central ones, we're going to do the same thing when we insert data. 
Okay? 
And so we're using the INSERT INTO. 
And this is a good time to point out that the keywords inside of SQL like 
insert into, the case doesn't matter. 
The names of the tables, the names of the columns, may or may not matter, and 
the actual data you put in that's case sensitive because that's your data. 
So I'm going to type INSERT INTO Artist. 
And the key thing that is important here is we're not specifying the id field. 
So if you recall, in the Artist table we have an id field and a name field. 
But if you look over here, the id field is an auto-generated field. 
It's not really showing up very well because we don't have a type. 
So the id field is auto-generated. 
So when I write this SQL
Play video starting at :1:24 and follow transcript1:24
I don't need to specify the id because as part of our contract we made a contract 
with a database that says, you assign that. 
So I'm going to run this now, INSERT INTO Artist with a name of Led Zeppelin. 
And if then we Browse Data and we go look at the artist, it's added the number 1. 
Kind of predictable. You can kind of guess where the next one's going to be, 
so the next one thing we're going to do is we're going to insert another artist in, 
we're going to insert AC/DC in. 
And, we inserted that. 
Now, if we go take a look at the data again, we got 2. 
And if we did a new record here, it would automatically provide this for us, right? 
I mean, it would let us change this, but it would want to pick the next number 3. 
So what we've done here is both inserted the record, 
but we've also established for within this database a new number. 
1 means Led Zepplin, and 2 means AC/DC. Okay? 
So then, the next thing we're going to do is insert in the Genre, 
kind of working outward in, and insert the value Rock and 
the value Metal, and now I'm going to show you a little trick here. 
You can actually, in this user interface of most of these things, 
not just this one, you can usually put more than one command in as long as you 
put a semicolon at the end of it. 
So I'm going to, if I did that right, semicolon at the end of it. 
So I'm going to do an INSERT INTO Genre of Rock and 
an INSERT INTO Genre of Metal and I'm going to run the SQL.
Play video starting at :3: and follow transcript3:00
Oh, I wonder if I did it twice. 
I did. 
So I'll just delete this record. 
Good bye. 
Delete that record. 
Good bye. 
So I did two inserts and I hit the botton twice, so 
that's how I ended up with two copies of it. 
So Rock for the rest of this lecture is the value 1 and Metal is the value 2.
Play video starting at :3:22 and follow transcript3:22
And again now when we're making the Track table we don't have to put Rock, Rock, Rock, 
Rock, Rock, we just put 1, 1, 1, 1, 1. 
Because 1 is not a string but it's a number, that turns out to be okay.
Play video starting at :3:33 and follow transcript3:33
So now we're going to take a look at the album and 
this is the first situation where we've got to do a primary key, a foreign key, right? 
So we got an Album table. 
And the Album has a primary key which is going to be automatically generated for us. 
And a foreign key called artist_id. 
Because the album points to the artist.
Play video starting at :3:54 and follow transcript3:54
And we only add data at the starting point of these arrows and so 
that's what we're doing. 
So this one we have to put in title but we don't have to put in id so we don't have 
to put that in but we do have to explicitly put in artist_id. So when you insert 
into Album you're going to have a title and then we're going to have an artist_id. 
This number we have to remember that 2 was AC/DC and 1 was Led Zeppelin. 
Now when we're doing this by hand it's a little tricky and 
you find yourself flipping back and forth to remember like, 
oh which one was Led Zeppelin, which one was AC/DC? 
And it seems like in the short term it'd be easier just to put the string in, but 
that's the whole thing we're trying to avoid. Okay? 
So for foreign keys we have to put the numbers in explicitly 
because we or the code we write has got to remember them. 
So remembering what these numbers are, the 2 and the 1, is a lot easier for 
a program to remember than it is for you to remember doing this by hand. 
Now normally you wouldn't insert this stuff, 
you would have code that inserts it, and it's really easy for it to say, 
oh I just inserted Genre, and just I inserted Rock, and I got back a 2. 
So actually you can get that, and so you the human don't have to remember this.
Play video starting at :5:5 and follow transcript5:05
So let's run these.
Play video starting at :5:7 and follow transcript5:07
This is our first one that's doing, 
and I'll put a semicolon here so we can do it all at once. 
And I'll only push the button once.
Play video starting at :5:21 and follow transcript5:21
Okay, and if we do Browse Data and we look at the Album,
Play video starting at :5:26 and follow transcript5:26
the id was auto-generated and artist_id was something that we chose and 
title was something that we put in, so now we're in pretty good shape. 
Now the last thing we're going to do is probably the most complex.
Play video starting at :5:38 and follow transcript5:38
But it's not.
Play video starting at :5:40 and follow transcript5:40
We have and id's come in for free, title is data, 
the length, rating, and count, that's just data. 
And then we have two arrows, right, pointing to Album and Genre. 
Album and Genre, and so we have two foreign keys. 
Now here is where we have replication now. 
Those two are going to the same album, and these two are going to the same album. 
Same genre, same genre. 
It's okay to have replication as long as they're numbers. 
That's really the essence of what we've done. 
We just like went in a big circle. 
Took replicated strings and turned them into replicated numbers. 
So these are okay. 
And so then what you're going to do, 
is you're just going to take each of these rows that you know. 
Well, we don't need that. 
Clear. 
Take each of these rows, and you know most of the data. 
We're going to put in the title, we're going to put in the album_id, the length, 
the rating, the count. 
Put all those things in
Play video starting at :6:36 and follow transcript6:36
explicitly, this comes automatically, and we're going to do that. 
title, rating, length, count, album_id, genre_id. 
And then we have the values, and then these are the two foreign key values. 
And they point to those rows. 
And again this is the point in time where you sort of have written down on a piece of paper 
what these little numbers were if you were doing it by hand.
Play video starting at :6:56 and follow transcript6:56
It won't be too bad.
Play video starting at :6:59 and follow transcript6:59
I luckily have them cut and pasted, so they are all easy for me. 
And if you are following along, then you just cut and paste these guys. 
And I'll be super lazy, and I'll copy all four SQL statements, and 
run over here, paste them in, and then I am going to put a semicolon, 
carefully, not on each line, but at the end of the values thing, 
So I'll put a semicolon on each of these guys. 
Forgot to put a semicolon on the last one.
Play video starting at :7:27 and follow transcript7:27
And I'm going to hit the run, and I'll look at the data. 
And I'll look at the Track data.
Play video starting at :7:33 and follow transcript7:33
And there we are. 
It's all there. 
We can kind of move this over. 
And that's the Track data and again we specified all those things. 
So if you look at all these tables, we've constructed them outwardly in. 
We started like at the Genre and the Artist and worked our way in so 
that we could establish those numbers so then we could link 
to those numbers as we put things in the Album and then we established numbers. 
And so the foreign keys are the starting points, the primary keys the ending points 
and we worked in. And so we have replication of numbers in this column but 
we don't have replication of strings. 
So the word Rock, if you look at all this data.
Play video starting at :8:8 and follow transcript8:08
Okay that's a bad example, forget that. 
The word Metal is better. 
That doesn't count, that's just a title, that's not really the word Rock. 
The word Metal as a genre only appears once in the entire 
database. 
And the thing about it is like what if there were a million of these, right? 
One million. 
You say okay, what's the difference? 
The word metal verses whatever. 
Versus the number 2. 
If there's millions of them it's not just that it takes up storage, 
it's it has to do with how much has to be scanned. 
So part of what you're trying to do in databases is reduce the amount of data that 
has to be scanned to get to a particular piece of information. 
And so the difference between Metal, which might actually be 128 characters, and 
a number, which is actually four characters, that turns out to be different. And it's not that 
we can't start on disk drives. Disk drives are big. It's just that we can't scan past 
it fast enough and we can't built indexes so we can jump past it even faster, okay? 
So that's what we have achieved in this section, 
is we've inserted all these data and we've linked things together and 
we've modeled relationships and connection points rather than replicating data.
So, we're about to come full circle. 
We just created these many database tables, 
we've spread things out, we've linked them all back together with these numbers. 
And it seems like we just created a mess of everything. 
But now we're about to bring it all back together using the JOIN. 
We finally have touched the relational power and 
it may seem painful, but this is important, especially when data scales. 
And if what you're doing matters, then data's going to scale. 
You can't say, oh my data is so small I don't need to do this. 
Well, if you're doing it, and it's big, and you're really doing data analysis, 
and it's like something you're doing professionally, 
you tend not to do small things professionally. 
You tend to do large things. 
So this notion of primary keys, and foreign keys, and 
the little numbers that point to stuff, that's what it's all about.
Play video starting at ::58 and follow transcript0:58
So we need to reconstruct, for 
our user interface, the data and reconnect all these connections.
Play video starting at :1:6 and follow transcript1:06
And the SQL syntax that allows this to happen is the JOIN operation. 
And the JOIN basically says, we are selecting data from more than one table. 
And part of the JOIN operation is the ON clause that says when we want to connect 
one row and one table with a corresponding row in a different table. 
And so we have this example here of our data, 
where we just want to sort of pull the artist title and the artist name out. 
Except that the artist title is in the album field, and 
the artist's name, because we did this relationally, is in the artist field, so 
we don't have it in one field so we have to pull across two tables. 
So that's where we say SELECT, and then we want the things. 
Now this is a syntax here where you have table name, field name, 
tablename.fieldname. 
The title column from the Album table, the name column from the Artist table, 
FROM, which is the same FROM we've done before. 
Here's a table joined with another table. 
And what we're doing is we're saying, 
let's make a super table that really is the rows of this table, 
as well as the rows from that table, and that's what the JOIN does. 
It's like, we're not going to one table, we're going to two tables. 
Then, in addition to the JOIN operation 
saying we're going to do all these tables, the ON clause 
decides when we connect a row in this table to a row in this table. 
So row to row, row to row, and the ON clause that we're going to write 
is when the album's artist_id that is from the Albums table, 
the foreign key, the start of our little arrow, is equal to 
the id field from Artist, Artist.id, so it is the destination. 
So, this is the starting point of the arrow and 
this is the ending point of the arrow. 
So, this is the start. 
This is the end. 
So, that's matching, reconnecting all the arrows for all the corresponding rows. 
Select these two fields, one field from each table, and then we got to 
glom the two tables together, but only connect the rows when this is true. 
For me, I would call this when.
Play video starting at :3:16 and follow transcript3:16
Some people prefer to write this as a longer WHERE clause, 
some databases prefer that. 
I tend to like using the ON clause, so I don't kind of confuse my WHERE clauses. 
But if you learn the WHERE clause trick, it's the same as the ON clause. 
So let's run this one.
Play video starting at :3:32 and follow transcript3:32
That's already in there. 
Oops.
Play video starting at :3:35 and follow transcript3:35
So I'll run it.
Play video starting at :3:37 and follow transcript3:37
So here I go. 
I've got the title. 
Oops. I've got the title from one table and 
the name from another table. 
And we joined them all together. 
And we had an ON clause that tells when they're supposed to be connected.
Play video starting at :3:52 and follow transcript3:52
Okay? 
So we can look a little more deeply into this relationship that we have, right? 
We can, you know, clear this. 
Look a little more deeply into the relationship that we have here 
by actually looking at all the data that's actually participating in 
the connection between these two rows. 
So here we once again have our SELECT, and 
our FROM clause goes between Album and Artist. 
So we're kind of, this is our super row. 
From the Album table and the Artist table. 
That's Artist, that's Album. 
And we have the foreign key relationship still.
Play video starting at :4:27 and follow transcript4:27
And we're going to add to this SELECT these two fields. 
Everything is the same as before, 
except we're going to show you how this connection is made, okay? 
So we're going to select the title, the artist_id, the artist's id, and name. 
So you can see how we're seeing the whole table at this table. 
These things have been joined together like there's glue in the middle 
between them. 
They've been glued together, and 
they're glued together in the situation where these two things match. 
So if you type that, that's what you see. 
And so that's a way these don't really need to be shown, but 
they are the source of the connection. 
Okay? 
So that's the source of the connection, and by just selecting them, 
you can see what it looks like.
Play video starting at :5:15 and follow transcript5:15
Okay, so let's construct another one. 
Let's say we want the Tracks title and the Genre's name. 
And if we take a look at the Track, right, we've got genre_id. 
Now we have some replication here. 
And then we do need to do this lookup, right? 
And we want to see all the tracks. 
Right? All the tracks along with their genres. 
Right? 
Rock, Rock, Metal, Metal. 
So now we've reconstituted the duplicates. Right? 
This is what the user wants to see. 
But this is what we're storing in our database. 
All right? 
So again, we say SELECT Track.title. 
That's this thing. 
Genre.name. That's that thing from a different table. 
FROM Track JOIN TO Genre. 
So that makes, 
like, this big blob thing that's a super row, that smears across two tables. 
And then we have an ON clause. 
And you'd think these are hard to construct. 
But, oh this is the Track table. 
There is a foreign key name named genre_id. 
Oh, and that's going to be equal to tablename.id. 
Right? 
I almost cut and paste these things so fast as I write them. 
And so they get easier and easier and easier, when you're going from the Track table to 
the Genre table, and the syntax that I use for the connection is very canonical. 
I do it over and over and over again. 
Okay? 
So let me run this guy and there we go. 
We've reconstructed the replication. 
But this also a good time to show you a little bit more 
about what's going on underneath this join, right? 
And now it all seems pretty and simple and this ON clause. 
But what happens if we just take out the ON clause? 
Select these two things from these guys glued together. 
Somehow we've glued these two tables together. 
So if you don't have an ON clause what happens is it basically says 
all combinations. All combinations. 
So there's four rows here and two rows here. 
So all combination of each row here. 
So this turns into 2, this turns into 2, this turns into 2, so that turns into 8. 
Now if this had 100, and this had 100, that'd be 10,000. 
And so if you don't have an ON clause it ends up with all combinations. 
And we can show this. 
So this is exactly the same SELECT statement. 
Track.title, genre_id, Genre.id, 
we're adding the middle joiner guys that would have been an ON clause. 
And we're saying FROM Track, JOIN with Genre, and no ON clause. 
Okay, that's the thing that's changed. 
We added these two columns and we took away the ON clause. 
So let's take a look at what happens when we run this one. 
And lines don't matter, so 
the fact that I put this on multiple lines you will see it doesn't care.
Play video starting at :8:1 and follow transcript8:01
And so you can add spacing and lines to make your SQL look prettier. 
I do that all the time, I indent them. 
Indenting has no significance, but it is still very pretty. 
So now we see that we're getting all the combinations. Right? 
1, 1; 1, 2; 1, 1; so Black Dog has got both genres. 
So it got genre 1 and genre 2. 
Because we don't have an ON clause, so it's not interested in matching. 
And so you can think of a JOIN, 
you can think of a JOIN as building 
across both tables all possible combinations between the tables. 
The ON clause is throwing away the ones that don't match.
Play video starting at :8:43 and follow transcript8:43
Or a better way to say it is it's picking the ones that do match, right? 
We like this combination. 
We like this combination. 
We like this combination. 
And we like this combination. 
That's what the ON clause is doing, 
is it's picking the ones where there's a match. 
If you don't have the ON clause, then boom. 
All combinations, 1 to 2. 
This is one row and it's being combined with that. 
This the the next row and we want both combinations. 
This is the third row, all combinations; fourth row, all combinations, 
and then the ON clause wipes out the non-matching ones.
Play video starting at :9:25 and follow transcript9:25
Whoops, I did it wrong again. 
I keep doing it wrong, but you get the idea. 
So that's the ON clause.
Play video starting at :9:33 and follow transcript9:33
That's really how it works, and frankly this is one of the things when I first 
looked at, it must be doing that but it doesn't do that. 
When it sees the ON clause it's really clever about pulling things in. 
Super clever. 
Again, that's not our problem. 
So now it can get complex. 
Because now what we want is the track title, 
the artist name, the album title, and the genre name. 
And this looks like a lot of stuff, but if you follow it, it's a pattern. 
So we have a SELECT, these are the things we want. 
That is the list of the output we want. 
We're not interested in all the id's. And we have to have this long FROM clause, 
that says, Track join with Genre join with Album join with Artist. 
That's all the rows, all the tables concatenated together, 
and then the ON clause, which seems kind of tricky, but now we start. 
We start from Track and work out. 
We have the foreign key in Track of genre_id is equal to the genre's primary key. 
And the Track's album_id is equal to the album's primary key, and 
there's one more foreign key and that is the Album's artist_id equals the Artist.id. 
So go back to that little picture that we had 
this that pointed to this, that pointed to that, that pointed to that.
Play video starting at :10:46 and follow transcript10:46
We just look at this, the picture, and this is why the pictures are so 
important, and we reconstruct all this. 
And so this for me, it may look a little complex. 
But after you do it a few times, 
you realize that the naming convention really, really saves you, okay?
Play video starting at :11:2 and follow transcript11:02
Let me show you that, select this whole monstrous mess.
Play video starting at :11:9 and follow transcript11:09
Type her in, and then run it.
Play video starting at :11:13 and follow transcript11:13
And we've reconstructed it, right? 
Now, we've got replication here, but that's the output. 
That's the beauty of databases, you reconstruct any replication, but 
you don't actually store the replication. 
And that's why you have to learn to write JOIN clauses.
Play video starting at :11:28 and follow transcript11:28
So if we think about this, we've gone full circle. 
it's taken us, just like any start-up, 
it just took us like three days to build our product. 
We started with a user interface that we designed that had replication. 
Then we came up with a data, a logical data model, then a physical data model, 
then we inserted all the data, 
we connected things with numbers instead of strings. 
And now we use a JOIN to reconstruct it. 
And so, we start here. 
We go through a step, a step, a step, a step, and then we come back to here, 
and we're able to reconstruct, in effect, 
the output that our end users are going to want to see. 
Except now we can handle millions or billions of rows, 
because we have carefully constructed a data model that makes sense.
[MUSIC] 
Hello, everybody, welcome to Python for Everybody. 
We're going to do some code walkthroughs actually running some code. 
And if you want to follow along with the code, 
the sample code is here in the materials of my Python for Everybody website. 
So you can take a look at that. 
So the code we're going to look at is from the database chapter, 
and we're going to look at tracks.py. 
So a lot of the lectures that I give in this database chapter are just about SQL. 
And this is really about SQL and Python, so I'll go through this in some detail. 
So the code that I'm going through is in tracks. 
There is also tracks.zip that you can grab that has these two things. 
It's got this library.xml file, which you can export from your, 
if you have iTunes, you can export this, or you can just play with my iTunes. 
And so this is also going to review how to read XML. 
So we're going to actually pull all this data. 
And this XML that Apple produces out of iTunes is a little weird, 
in that it's kind of key values, and so you see key value pairs. 
And it even uses the word dictionary. 
And so it's like, I'm going to make a dictionary that has this, 
then a dictionary within a dictionary. 
This, to me, could be so 
nice if it was JSON because it's really a list of dictionaries. 
This is a dictionary, then another dictionary, 
then another dictionary, and then the key for that dictionary. 
And it's a weird, weird format, but we'll write some Python to be able to read it. 
So you export that from iTunes, 
and you can use my file or you can use your file. 
It might be more fun to user your file. 
And so here's tracks.py, we're going to do some XML. 
And so we import that, 
we're going to import sqlite3 because we want to talk to the database. 
And then we're going to make a database connection. 
And in this, once we run this, you'll see that that file will exist. 
And so right now, if I'm in my tracks data, that file doesn't exist, 
but what we'll see is this is actually going to create it. 
Now, remember that we have a cursor, which is sort of like a file handle, 
it's really a database handle, as it were. 
And in order to sort of Bootstrap this nicely, we are going, because this code is 
going to run all the time, it's going to run and read all of library docs XML. 
In later things, we won't wipe out the database every time. 
And so I'm executing a script, 
which is a series of SQL commands separated by semicolons. 
So I'm going to throw away the artist table, album table, and track table, 
very similar to the stuff we covered in lecture. 
And then I'm going to do the create table, and I'm doing this all automatically. 
And you'll notice this is a triple-quoted string, so this is just one big, 
long string here. 
And it happens to know that it's SQL, thank you, Atom, for that. 
And so it creates all these things. 
Now, it's not quite as rich as the data model we built 
because there's no genres in here. 
And so it's artists, album, track, 
and then there's a foreign key for album ID and a foreign key for 
artist ID, which is sort of a subset of what we're doing.
Play video starting at :3:29 and follow transcript3:29
And so when that's done, that actually creates all the tables, and 
we'll see those in a moment once we run the code. 
Then it asks for a file name for the XML, right, and so that's what that is.
Play video starting at :3:45 and follow transcript3:45
I wrote a function that does a lookup that, it's really weird because 
if you look at these files, like in this dictionary, there is a key, right? 
And so the key of this dictionary, 
this really could've should've been a key value pair.
Play video starting at :4:2 and follow transcript4:02
There's this weird thing where the key for an object is inside of the object. 
And so we're going to grab, for all, 
we're going to loop through all the children in this outer dictionary and 
find a child tag that has a particular key. 
And so you'll see how this works, and 
this was something I was going to use over and over again. 
And so the first thing we're going to do is we're going to just parse this sting. 
And this is the string. 
And then this, of course, is an XML ET object. 
And now we're going to say, we're going to do a find all. 
And so this shows how the find all. 
We're going to go the third level dictionaries, 
we want to see all of the tracks. 
And so we have a dictionary, and a dictionary, and a dictionary. 
And so what we want is all of these guys, right, all those guys right there, right? 
Track ID.
Play video starting at :5: and follow transcript5:00
So we're going to get a list of all those. 
That'll be the first one.
Play video starting at :5:4 and follow transcript5:04
This will be the second one because the find all says,
Play video starting at :5:11 and follow transcript5:11
Find the dictionary key, then a dictionary tag within that, and a dictionary tag. 
And then it will tell how many thing we got. 
And then we're going to loop through, and 
entry is going to iterate through each of these. 
And see we'll get our name, and our artist, 
Another One Bites the Dust, the Queen, and away we go. 
And then the next time to the loop we'll hit this one, okay? 
So then what we're going to do is we're going to go through all those entries, 
and if there is no track ID, and if that's this track ID field, where are you hiding? 
Track ID, we don't have that, we're going to continue.
Play video starting at :5:51 and follow transcript5:51
And then we're going to lookup the name, artist, 
album, play count, rating, and total time, okay? 
And so here they are, play count, 
a lot of those things that we had in the sample lecture that I did. 
And we're going to look those things up, and 
we're going to do some sanity checking. 
If we didn't get a name, or an artist, or an album, we're going to continue. 
We're going to print them out. 
And then we are going to ask or 
get, remember how you have to get the primary key of a row so you can use it? 
So the way we're going to do this is we're going to do an insert or ignore. 
And so this or ignore basically says, because I said that the artist name, 
go up here, I said the artist name is unique. 
Which means if I try to attempt insert the same artist twice, it will blow up, okay? 
Because I put this constraint on that, except when I say insert or 
ignore that basically says, hey, If it's already there, don't insert it again. 
So what I'm doing here is insert or ignore into artist, so this is putting a new 
row into the artist table, unless there is already a row in that artist table.
Play video starting at :7:8 and follow transcript7:08
And this syntax right here, 
the question mark is sort of where this artist variable goes. 
And this is a tuple, but 
I have to sort of put the comma in to force it to be a tuple. 
So this is a way you have a one tuple. 
And then what I need to know is I need to know the primary key of this particular 
artist row. 
Now, this line may or may not, if it actually done the insert. 
And so I need to know what the ID for that articular artist is. 
So I do a select id FROM Artist WHERE name =. 
Now, it either was already there, or I'm getting it fresh and brand new. 
So I do an artist_id equals I fetch one row, and it's going to be the first thing, 
given that I only selected id. 
And so this artist_id is going to be the id. 
Now, now I have the foreign key for the album title, right? 
And so now i'm going to insert in the title artist_id, 
this is the foreign key to the artist table. 
And I got this value that I just moments ago retrieved, and I got the album title. 
But this also is insert or ignore because, and now if you look, 
I have unique on the album title. 
Yeah, unique's on the album title, so that'll do nothing. 
It doesn't blow up or ignore, it says, 
don't blow up, just do nothing because this next line is going to select it. 
And I grab the album's foreign key for either the existing row or the new row. 
And then I'm going to insert or replace. 
And so what this basically says is if the unique constraint would be violated, 
this turns into an update. 
Now, not all SQLs have this, but SQLite has this, that basically says insert or 
replace.
Play video starting at :8:56 and follow transcript8:56
Some SQLs are totally standard, some things we do, 
like this SELECT statement is a totally standard part of SQL. 
Then the INSERT is totally standard, but INSERT OR REPLACE, 
an INSERT OR IGNORE is not totally standard. 
But that's okay, it works for SQLite, which is what we're doing. 
And so we have the title, album_id, length, rating, and count. 
And then we have a tuple that does all that stuff, and 
of course, the title is unique, all right? 
The title is unique in the track table, as well, and so we've inserted that. 
So the clever bit here is dealing with new or existing names in these three lines. 
And we see that pattern twice here, where we're doing that, okay? 
So [LAUGH] there's not much left to do except run this code. 
Hopefully it runs.
Play video starting at :9:44 and follow transcript9:44
python3 tracks.py, and 
Library.xml, whoosh! 
Okay, so that is my, so we found 404 of 
those dictionaries, 3D dictionaries. 
And now it's starting to insert them, insert them, insert them, insert them. 
And we can take a look at, so we can do an ls -l or 
Duron windows, we'll see that we made a track database. 
We extracted this data from the library and we made a track database, and 
we have all these foreign keys. 
So let's go take a look at the SQLite browser, 
File > Open Database > trackdb.sqlite. 
And come on up, where'd you hide?
Play video starting at :10:36 and follow transcript10:36
I got it minimized, so there you go. 
Let's look at the database structure. 
We have an album, this is the structure, artist and track, we have no genre genre. 
And this is all like we did it by hand, except Python did all this work for us. 
If we take a look at the data and we start from the outside in, we have the artist 
names and their primary keys, right, there's the artist names and primary keys.
Play video starting at :11:2 and follow transcript11:02
And then we have the albums, and we have the artist IDs, 
[SOUND] seeing the artist IDs, how nice those are. 
So we have the primary key here and the foreign key there, and 
then we have the title. 
And if we get to the track, We have the album ID, and away we go. 
So if I was clever, I could be able to type some SQL. 
Great, if I was smart, I'd had this in a paste buffer. 
So SELECT,
Play video starting at :11:38 and follow transcript11:38
SELECT Track.title, Album.title, 
Artist.name, I think. 
Artists has names, and albums have titles, yes. 
Okay, so I can do that. 
FROM Track JOIN Album, oops, 
Album JOIN, make that little bigger.
Play video starting at :12:16 and follow transcript12:16
Then over here, Album Track JOIN Album JOIN Artist.
Play video starting at :12:24 and follow transcript12:24
Now I need an ON clause, and I can say Track.album_,
Play video starting at :12:35 and follow transcript12:35
id = Album. 
Notice how I know the name that I named these things. 
AND Album.artist, this is so 
great when you use a naming convention, 
Artist.id, I think that might work.
Play video starting at :12:59 and follow transcript12:59
So let's just see what get when we type that into the SQL box here, Execute SQL.
Play video starting at :13:8 and follow transcript13:08
Run, yay, I got it right the first time! 
All right, so that's basically my nice little joined up track list. 
I'm so happy that I got that right the first time.
Play video starting at :13:18 and follow transcript13:18
Okay, well, so you can play with this yourself. 
Play with this tracks, 
maybe make an export of your own iTunes library and run it with that. 
And so I hope that you found this particular bit of code useful, okay? 
Cheers. 

### Multi-Table Database - Tracks
In this assignment you will parse an XML list of albums, artists, and Genres and produce a properly normalized database using a Python program.
________________________________________
This course uses a third-party app, Multi-Table Database - Tracks, to enhance your learning experience. The app will reference basic information like your name, email, and Coursera ID.
Coursera Honor Code  Learn more
 
I, elham fazel, understand that submitting work that isn’t my own may result in permanent failure of this course or deactivation of my Coursera account.
Hi, this is Chuck Severance, and here we are at yet 
another Face to Face Office Hours. 
This time we are in Perth, at the western end of Australia, 
the world's most remote capital city. 
So I want to introduce you to some of your fellow students here from Perth. 
We'll hear your name, and say hi if you like. 
>> Hi, my name is Ronald, and this is my seventh Coursera course. 
>> Excellent. 
>> And, yes, I'm wearing this t-shirt here, I just want to show my friend. 
>> Okay. >> Because it's got this website and 
you know he wanted me to wear it while on Coursera. 
>> And so we've got your t-shirt. 
Congratulations on your seven Coursera classes. 
You're pretty much using this like a master's degree, right? 
You got a bachelor's degree and 
you're kind of making up your own master's degree. 
>> Yes, I did computer science back in the 90s. 
And I'm Solaris and Linux system admin. 
And I'm just doing this just for fun. 
And nostalgic, because I am in the computer business. 
>> Yeah. 
Okay. >> Nice meeting you anyway. 
>> Nice meeting you. 
Nostalgic >> Hello. 
>> Hi. I'm Diana. 
I'm from New Zealand and it's my first Coursera course. 
>> You're also formally from Oxford, right? 
>> I didn't finish my doctorate. 
>> Oh [LAUGH]. 
>> Hi, my name's Eloise, and 
I'm using Coursera to sort of fill up some gaps in my education. 
And I've had a lot of fun tonight. 
>> Okay. 
>> Hi, I'm Terry. 
>> I'm enjoying Chuck's course.
Play video starting at :1:34 and follow transcript1:34
Yeah. It's good enough. 
Coursera courses are something different though. 
>> Yeah. 
Okay. 
So there you have it. 
Another successful Face to Face Office Hours from Perth, Australia.


[MUSIC]
Play video starting at ::42 and follow transcript0:42
When I returned to Switzerland, I got an invitation at the University 
of Zurich and at the ETH to introduce computer science as a new subject.
Play video starting at ::56 and follow transcript0:56
And, of course, being a self-trained man essentially, 
I looked what tools were available and that was rather a disappointment. 
Yes, yes, there was ALGOL available, which convinced me through its rigor and its
Play video starting at :1:18 and follow transcript1:18
good structure, but it had a lousy implementation.
Play video starting at :1:24 and follow transcript1:24
And I felt using that ALGOL could only 
reduce the chances of it ever being accepted.
Play video starting at :1:34 and follow transcript1:34
And on the other side, there was 
only Fortran, which I found unsuitable for teaching.
Play video starting at :1:41 and follow transcript1:41
Not to talk about Assemble language or Assemble code. 
So I decided to continue my work from Stanford
Play video starting at :1:50 and follow transcript1:50
and implement, no, not another ALGOL 
compiler, but what later became known as Pascal.
Play video starting at :2:1 and follow transcript2:01
I'd had been a member of the IFIP 
working group and there were finally two proposals. 
One by Arthur Langharton from Amsterdam, and one from me. 
And I might say I lost out,
Play video starting at :2:19 and follow transcript2:19
and then I decided to implement it just in spite of it all 
because I needed it, I needed it for teaching.
Play video starting at :2:30 and follow transcript2:30
And that's how what lead to one and a half years later, to Pascal 1969. 
And in 1971, I used it for the first time in an introductory programming course.
Play video starting at :2:44 and follow transcript2:44
>> It kind of took a life of its own, right? 
It took a life of its own in the, in corporate, in the corporate world. 
I mean, >> Yes, yes, although I must say, it took some time. 
We had implemented Pascal on quite a lot of different computers.
Play video starting at :3:7 and follow transcript3:07
And we had helped other universities who 
wanted it, to transport it to their computers 
over Pascal P, the portable system.
Play video starting at :3:19 and follow transcript3:19
But the real breakthrough came actually with the advent of the microcomputer.
Play video starting at :3:25 and follow transcript3:25
Apple II, particularly, also 
Tandy and some others, and 
they brought out UCSD Pascal and
Play video starting at :3:41 and follow transcript3:41
Pascal implementation by Borland, Turbo Pascal.
Play video starting at :3:47 and follow transcript3:47
And and they were selling not only compilers, 
but an integrated system with text editor and debugger 
for something like $50. And that really made the difference, at 
a time when compilers would still cost thousands of dollars for large machines. 
And now of course they spread into the 
areas where people did not come loaded with
Play video starting at :4:14 and follow transcript4:14
bad preconceptions, you know. They started learning programming from scratch.
Play video starting at :4:21 and follow transcript4:21
And that's how computing was brought into homes and schools. 
>> What other language would have been suitable for the 
mircroprocessor revolution in the early days of the microprocessor revolution?
Play video starting at :4:35 and follow transcript4:35
>> Yeah, well that was of course the point, yes? 
There was only one competitor, that was Basic.
Play video starting at :4:44 and follow transcript4:44
But from the pedagogical point of view, I think Pascal was the right thing. 
>> But even if you think of it 
as a systems development language, on early microprocessors. 
>> Mm-hm. 
>> The fact that you had real interfaces. 
>> Yeah, yeah. 
>> And type. 
>> Yeah. 
>> And the ability to try to kind of at some level make contracts. 
>> Types and- 
>> Basic, and I mean so Basic really wasn't a competitor at all. 
I think, if you start thinking about doing something... 
>> Well, for beginner's courses it was, of course. 
>> Yes, 
>> And in particular in the US people 
were not used to structured languages, you know. 
Even Fortran was a fairly flat thing, and, but Pascal caught on quite well 
also in primary schools. 
>> And, and, and Pascal was the, sort of, the 
API definition for Apple all the way through Macintosh, right? 
>> That's right. 
>> Did you interact with UCSD, with Apple, or by then was it simply 
kind of a public, a public good? 
>> It was public good. 
Yes.
Play video starting at :5:46 and follow transcript5:46
No, I had very little interaction, really almost none. 
Yeah. 
The Atlantic Ocean is too wide, or was too wide for close 
interaction, I think, and we had always distributed our software for free,
Play video starting at :6:8 and follow transcript6:08
covering the cost of the tape.
Play video starting at :6:11 and follow transcript6:11
And so of course nobody had an obligation to fall back on me. 
>> Certainly, in the beginning of computing, open source wasn't something we 
thought of as special or different, it was just a way of behaving. 
>> Yes, yes. 
I think universities always behaved like that, open source. 
I mean, universities have an interest in spreading 
their ideas, and not in protecting them. 
>> Now kind of talk about the follow-on 
the languages that you carefully didn't name Pascal.
Play video starting at :6:45 and follow transcript6:45
>> Yes, I did not, and from the commercial point of view 
it's regrettable because if I had called Modula Pascal 2 
and Oberon Pascal 3, they wold have had better success. 
Yes, Modula-2 came nine years after Pascal. 
And it was a language designed for system development 
influenced also by Mesa, developed at Xerox Park where I spent a sabbatical,
Play video starting at :7:21 and follow transcript7:21
Mesa itself based on Pascal, and the primary new 
feature of Modula was the module. And we fixed the interface 
specification, and implementation, to separate compatibility of modules. 
Separate compatibility with tight 
interface type checking, that's of course what was missing in Fortran.
Play video starting at :7:54 and follow transcript7:54
And so linking different modular modules together 
is as safe as just programming in one module, and that was absolutely crucial thing. 
>> So talk about the transition then from Modula to Oberon. 
>> That took place after my second 
sabbatical at Xerox Park starting '87, '89. 
I and my colleague Jurg Gutknecht had actually become convinced 
that the future lay, particularly for teaching programming, 
in simple languages. And Modula, to our 
taste, had already been overloaded with features and facilities. 
And so we wanted to, to, clean up, 
a modular tool and that resulted in Oberon. 
We added essentially only one feature, an 
important one though, that was type extension.
Play video starting at :9:3 and follow transcript9:03
And together with type extension, and together with 
procedure variables, which were already present in Modula,
Play video starting at :9:13 and follow transcript9:13
you could implement the full scheme of object orientation. 
So,
Play video starting at :9:21 and follow transcript9:21
from the outset that was the 
innovation in Oberon, simplicity plus object orientation. 
>> So Oberon also begat an operating system, correct?
Play video starting at :9:33 and follow transcript9:33
>> Yes. 
Remember I had spent my sabbatical, the first one, at Xerox in '76, '77. 
And I was given an Alto computer, for myself alone, under my desk. 
And that was, of course, an absolute change in, in the way computers were used. 
At home I still had a terminal, linked with a thin wire 
to a big machine, which was shared, I mean, with hundreds of others.
Play video starting at :10:7 and follow transcript10:07
And so having my own computer, with a bitmapped screen, you know, able to do 
much more flexible text editing, and forms, and graphics, and all that. 
That was really for me a revelation. And I decided 
that I wouldn't want to program with these old dinosaurs any more 
and I had to have one of these things too. But they were not on sale. 
They couldn't be bought. And the only thing 
I could do was to decide to build one myself. 
And that's how I diversified into hardware.
Play video starting at :10:53 and follow transcript10:53
Fortunately I had been trained as an electrical 
engineer, and so it was a bit easier. 
But in the meantime, which was something like 15 years, electronics 
had undergone a big change, you know, from, I was still trained on vacuum 
tubes and now they were to, not only to transistors but to integrated chips.
Play video starting at :11:16 and follow transcript11:16
But it was really fascinating. And with very little money, I think I got 
about 50,000 francs as a starting capital, 
we built a little workshop and built prototypes.
Play video starting at :11:31 and follow transcript11:31
And they were of course then tuned
Play video starting at :11:35 and follow transcript11:35
to Modula. The language Modula, and the compilers, and 
the operating systems, were closely connected to, to the Lilith computer, 
it was called, and the whole thing was in a way repeated ten years later 
with a pair of Oberon language, Oberon 
operating system, and the Ceres computer. 
[MUSIC]. 
>> I felt that we should apply the same principles of simplicity and 
well structuredness that we used in software also to hardware.
Play video starting at :12:21 and follow transcript12:21
And this is now possible because of these FPGAs.
Play video starting at :12:26 and follow transcript12:26
And so I got a Xilinx development tool with an FPGA in it.
Play video starting at :12:33 and follow transcript12:33
I implemented a processor, I called it RISC,
Play video starting at :12:39 and follow transcript12:39
but it is much simpler than the ARM or the MIPS or the SPARC.
Play video starting at :12:45 and follow transcript12:45
Really again concentrating on what is essential and presentable to students. 
The processor's very low code takes about three pages,
Play video starting at :12:57 and follow transcript12:57
And then, and I'm just about finishing this, 
I wrote an Oberon compiler for that RISC architecture 
including compiler and linker and downloader.
Play video starting at :13:11 and follow transcript13:11
And so now we start, or I start, revising the book,
Play video starting at :13:17 and follow transcript13:17
completely rewriting the chapters on the compiler and the linker load.
Play video starting at :13:25 and follow transcript13:25
But the rest remains surprisingly as it was with relatively few 
changes, which shows that the ideas there were quite modern. 
>> Do you have any FPGAs that are programmed? 
>> Yes, this one is it, unplug it. 
That's just a Xilinx development board which costs about $100. 
>> And this is your microprocessor?
Play video starting at :13:55 and follow transcript13:55
I mean- >> This is the FPGA. 
>> Right. 
>> Into which I have downloaded the 
the RISC processor. 
>> And so when you're finished downloading that, it becomes the microprocessor? 
>> That's right, exactly. 
>> And how is memory come from?
Play video starting at :14:14 and follow transcript14:14
Oh, it has memory.
Play video starting at :14:15 and follow transcript14:15
>> These two chips are one megabyte.
Play video starting at :14:20 and follow transcript14:20
So by nowadays standards, of course, it's a small computer, but 
we can easily fit our Oberon operating system. 
>> We understand what a FPGA is and 
then you're building up, effectively, from gates. 
>> Right, right. 
That's the idea for teaching.
Play video starting at :14:41 and follow transcript14:41
And in the new version of the book there will also be a chapter on this. 
Has to be, to make it complete. 
[MUSIC]

Okay, hello everybody. 
This is the second Office Hours in Barcelona given that I lost the video for 
the first Office Hours but thankfully I was here another day. 
So we had another Office Hour. 
A few people came to both of them and then we have a bunch of new people. 
So I'd like you to meet the people, your fellow students from the class, okay? 
And you can say hi even though you're not in the class yet. 
>> Hi, I'm Esha and I'm planning on starting 
the Internet History class >> Okay, 
I'll give you an Internet history sticker, you don't even have to finish. 
>> Hi, I'm Hetish and Python is a lot cooler than Petri. 
>> [LAUGH] No, no, no, no, no. 
>> Hi- >> I'm going to cut that part out. 
>> Hi, my name is Isabel and I'm taking the Python Specialization and 
I will finish the Capstone. 
>> Yes. 
>> Hi, my name is Christina, I'm a linguist, and 
I encourage all linguists to learn Python. 
>> Great. 
>> Hi, my name is Enrico, I'm a Java programmer, I'm learning Python. 
Thank you. 
>> Thank you. 
>> Hi, my name is Marca, I'm taking the Python Specialization, 
it's very interesting and I highly recommend it to everybody. 
>> Okay. 
>> Hi, I'm Shane and I'm privileged to meet Dear Mister Chalk. 
>> I'm privileged to meet you. 
>> [LAUGH] Okay, and I think all of you folks are envious about us 
because we had a very interesting companionship with our dear teacher. 
>> Well thank you.
Play video starting at :1:17 and follow transcript1:17
>> Hello I'm Theresa.
Play video starting at :1:20 and follow transcript1:20
I was enjoying the Python courses and I think that you can learn a lot with it. 
>> Thank you, thank you. 
Well, so there we go. 
Another successful Office Hours with Cavesa and 
wonderful students here in Barcelona. 
So cheers. 
See you next time. 
[MUSIC] 
It is like a pigeon. 
It's exactly like a pigeon. 
Okay.
Play video starting at :1:48 and follow transcript1:48
>> [LAUGH] >> So here we go. 
So I'll put this close to your face but it's a GoPro so 
it's got a real wide angle. 
So it's not only taking a picture of your nose but 
it gives really good audio that way. 
>> Okay. 
>> Okay?
Play video starting at :2:3 and follow transcript2:03
So I'll start. 
>> That's the pro's mistake. 
>> [LAUGH] >> It is. 
[MUSIC]
So we've learned about foreign keys. 
We've learned about JOIN. 
We've learned about how to normalize data to remove duplicates. 
But there's still one more basic data modeling thing that we have to learn about 
and that's many-to-many relationships. 
And so everything we've done so far is what we call one-to-many. 
And that is, an album has many tracks. 
So at the end of these arrows, and we see these on some of the crow's foot 
data model diagrams, one end is like many and then there's one. 
So one album, and then many tracks. 
And so, this is the kind of thing that we've got. 
And we've got a foreign key in the many side. 
So that allows there to be many, many, many tracks for one album. 
And then another album would have many, many, many tracks. 
Right? And so that's the idea. 
There's a set of tracks that have the same I mean this is the duplication that we 
just got rid of and that's called a many-to-one or a one-to-many, okay? 
And so that is one form and it's the most common form and 
we see this in our tables where we have genre_id or album_id and we have 
duplication in here and this is the many side so there's many of these things 
for one of those things. 
And, as an example of biological mother and children, 
a biological, single biological mother might have many children. 
And this is also a crow's foot diagram. 
And this little like crow's foot says many, and then one shows right there.
Play video starting at :1:39 and follow transcript1:39
So when we're drawing these data model diagrams, 
which we haven't spent too much time with, 
we always draw them in a way so that we capture the manyness or 
the cardinality of each end of the relationship. 
Now, so that's one-to-many. 
But sometimes we have a relationship between data that's many-to-many, and 
frankly in our music data that we've been playing with, I already told you that, like, 
well there's actually many artists on an album. 
But I said don't worry about that. Well now we're going to worry about that. 
So the example that I took from Wikipedia is books and authors. 
There are many authors and many books. 
And so, one author may talk to many books, 
and one book may have different authors that they're connected to. And so 
we can't say that either of these is a one relationship, and so 
we call this a many-to-many. 
On both ends there's a many-to-many. 
But in terms of the table that we want to do, there is no way. 
You can't put a single foreign key in this side. 
Oops, come back. 
We can't put a foreign key in this table to point to Books. 
And we can't put a foreign key in Books pointing to Authors because that would be 
sort of a one on either side. 
And so we build a table in the middle, okay? 
And in Wikipedia they call it a junction table, all kinds of names for 
this thing, but what we do is we have a little table that we create. 
We still have a Books table and a Authors table, but 
then we have a table that models nothing but the connection between them and so 
we decompose this many-to-many relationship into a 
many-to-one relationship and a many-to-one relationship and these two things 
then we can model properly using the exact same techniques that we've been using 
all along. 
And so we end up with a table that has two foreign keys in it and no primary key. 
So let's take a look at how this looks when we actually build it and model it. 
So here we're going to have something I care a lot about, courses and users. 
So this has to do with the fact that one user is a member of many courses and 
each course has many users so the relationship between courses and users, 
the member-of relationship, is many on both ends. 
And we just can't model that directly. 
So we make a little mini-table in the middle, right? 
So we call this the membership table or the table called Member. 
We still have a User table and a Course table. 
And we have a primary key in the Course and the User table. 
And what we do is we have this Member table that has each row 
has two foreign keys. 
And it is a connection, so if you think of all the courses on one side, and 
all the users on another side, 
each connection, these could be friends of people, 
each connection has one row 
that connects a particular course with a particular user. 
And that's how it works. 
And so then that decomposes our many-to-many relationship 
into two halves of two many-to-ones, 
that then models the many-to-many relationship between the two tables. 
We don't put an id. 
We don't put that in there, because we can make a composite key, 
which is, both these two things are the primary key for that table. 
They're both numbers, duplication is allowed and so 
this is all perfectly great. 
Now sometimes we'll model something like put a role here so that you can say okay, 
this is courses and users. 
We might indicate that this particular user/course combination also 
is an instructor and this particular is a student, right? 
And so we can sometimes put a little bit of extra data on the link itself, and so 
we have a little bit of data that we add down there. 
Okay? 
So we make this little table in the middle, and so here we're going to run 
some databases. I'm going to start with a fresh database. I'm going to make a User 
table, the main difference is I'm going to give the primary key for the users, 
I'm going to make a Course table, and this is our standard primary key stuff. 
I'm going to have a name and email for the users, and a title for the courses. 
And then, those are just normal things that we're used to doing. 
But now what we're going to do is create this little connector table 
that's going to have two, it's going to have a role_id, and course_id. 
I mean a user_id and a course_id. 
And then we're going to model a little bit of data, right here in the middle, and 
we're going to model role. 
And this is going to allow us to say whether someone's a teacher or a student. 
And the other thing that we're doing that's effectively a substitute for this 
primary key is we're saying our primary key is actually two columns together. 
And it's the combination. 
So this forces it to be unique.
Play video starting at :6:14 and follow transcript6:14
But it's really the combination of user_id and course_id must be unique. 
Okay?
Play video starting at :6:21 and follow transcript6:21
So let's take a look at this.
Play video starting at :6:24 and follow transcript6:24
Let's actually go ahead and run some code. 
And so what I'm going to suggest that you do is to start with a brand new fresh database. 
Just click New Database. Right?
Play video starting at :6:36 and follow transcript6:36
And we're going to call this, I'll call it sql3, New Database. 
And, I'm not going to do my table there, I'm going to go over Execute SQL, 
which by now I hope is coming somewhat comfortable to you. 
And then, I'm going to grab. 
Actually, I'm going to grab these two. 
First we'll grab those two CREATE TABLE statements.
Play video starting at :7:5 and follow transcript7:05
I'll put a semicolon at the end of this one so we can run them both. 
Let's see if they worked.
Play video starting at :7:13 and follow transcript7:13
Yep, I've got a course and user, primary key, title, id, name, 
just exactly what we've got. 
And so now what we're going to do is we are going to 
execute the SQL to make the little connector table.
Play video starting at :7:30 and follow transcript7:30
So I'll paste that in, and I will run that.
Play video starting at :7:35 and follow transcript7:35
Let's see if it worked, and it did work. 
So we're all good, primary key.
Play video starting at :7:42 and follow transcript7:42
And now we're going to put some data in. 
So let's take a look at some data. 
When we're done, we've got that, which we've seen. 
And so we're going to insert some users and some courses, so 
let's take a look at that before we go doing it.
Play video starting at :7:55 and follow transcript7:55
So because these have auto increment primary keys and 
we're just going to insert the name and the email jane@tsugi.org and 
we're going to insert three users and then we're going to get the user id's and 
then we're going to insert three courses, Python, SQL, and PHP.
Play video starting at :8:11 and follow transcript8:11
So we'll just do those. 
Those are nothing special. 
They're no different than the things we've been doing all along.
Play video starting at :8:25 and follow transcript8:25
Go over here in SQL. 
They all have semicolons at the end.
Play video starting at :8:33 and follow transcript8:33
So it all ran, so we'll browse the data. 
We see the course data. 
And we see the user data. 
And there's nothing in the membership data. 
I mean, the database doesn't know that we've done anything like this. 
We just inserted some stuff over here. 
And what we're really doing is establishing the primary key in this 
id column. 
So Python is 1. 
SQL is 2 and PHP is 3. 
And so now we're going to actually put some data into the member column, and 
the user_id, course_id, role. 
So we're connecting one user to one course, and 
then assigning a role to that particular membership. 
So this is a membership record, who is a member of what and some aspect of it. 
And there can be a few things that are 
often a few more columns that you could do. 
So let's take a look at the thing we've got to do to actually 
insert users into the courses. 
Right? 
So here's the numbers that we've got. 
And so now what we're going to do is 
insert into, there we go, insert into the member table the enrollment records, as it were. 
So we've got to insert user_id, course_id, foreign keys, and then the role. 
And so this says, we're going to do user 1 is going to be in course 1, and 
we'll make 1 be the instructor, okay? 
And then we're saying
Play video starting at :9:44 and follow transcript9:44
user 2 is in course 1 as a student. 
User 3 is in course 1 as a student. 
User 1 is course 2 as a student. 
User 2 is in course 2 as an instructor. 
Etc., etc., etc. 
And so because we know what these numbers are in actual code 
we'll know what the numbers are. 
We know what the numbers are, and so 
we sort of put them right in the insert statements. 
And that's how we make our connections.
Play video starting at :10:10 and follow transcript10:10
So let's go ahead and run those,
Play video starting at :10:20 and follow transcript10:20
go to SQL and insert all those. 
Click.
Play video starting at :10:28 and follow transcript10:28
Oh yikes, hope I didn't do that twice.
Play video starting at :10:33 and follow transcript10:33
Nope, I didn't do it twice. 
I'm glad. 
Let me just refresh to make sure I didn't do it twice. 
Okay, so that's just the numbers that came from those insert statements and 
instructor, instructor, instructor, the courses, and the students. Okay? 
And so now what we have is we have 
in our database, we have now connected these things together. 
Right? So we've got them all connected 
together. We've got our User table, we've got our Ccourse table, and 
then we've got our connectors that go from here to here and here to here. 
And we are modeling a little tiny bit of data 
on the connection, is what we'd call that. 
On the connection, okay? 
So, let's get some data out of this table now. 
We are going to write a select statement, SELECT User.name, 
Member.role, and then Course.title. 
We're going to select those from the User, 
joined with the Member, joined with the Course, so 
we're going to join all those together into one big long row. 
We use the ON clause and the Member.user_id is equal to the user's id and 
the members and the courses, the membership course id is equal to the course's id. 
Member.course_id equals the course's id. 
Oh and then we're going to do cool stuff. 
We're going to order by the course title then the member role. 
The way these. 
And then member role descending and then the user name. 
So what this means is, the precedence is course title's the most important thing. 
The role's the next most important thing. 
And we're going to do that descending and 
then the user name is the third most important thing. 
So this is going to give us sorted by course first and 
then within course it's role first, and then for people that have the same role 
like this one has the same role, so this allows us to see the teachers first and 
then the students in alphabetical order because the role in 1 for teachers and 
0 for students, okay? 
So that's what we get when we make this join, and so 
we've kind of created an enrollment record. 
If we had a WHERE clause we could pick it for one particular course, etc., etc. 
So let's go ahead and run that select. 
It will be really boring if everything went well. 
Execute SQL. 
Paste that SQL in. 
And run that SQL. 
And so we see ordered by course, then ordered by role, 
and then within the same role it's ordered by student name. 
Okay? So that was an example of three things in 
the ORDER BY clause.
Play video starting at :13:18 and follow transcript13:18
Okay. So, you see this sort of working 
if you look at various data models. 
This happens to be a data model for your autograder actually. 
It uses a piece of software called Tsugi. 
And the interaction between the learning system and 
Tsugi has to model things like what course you're coming from, 
the membership you are, whether you're a teacher or not, and so if I look at this, 
not that you really need to look at this in great detail, we got this 
is a production software, a User table, a Context which is the same as course, and 
then the Membership, and the Membership has a many, many-to-one, one. 
So we have a many-to-many relationship between users and courses, but 
we model it with this little table that's the connector table. And, 
here's a role in there. 
As you might expect in any teaching and learning environment, 
you're going to keep track of the role. And I have a thing called the role override. 
And I also have two little things that keep track of when things happen. 
And so let's see.
Play video starting at :14:20 and follow transcript14:20
So some of these. 
Some of these. 
So that's a many-to-many relationship. 
Most of these other things are many-to-one. 
This is a many-to-one relationship. 
And so this is a modified crow's foot. 
This is a many-to-one relationship between the course link. 
This happens to be the link that you click on. 
Blah blah blah blah blah. 
And this is actually your grade. 
And results are great, and so there's many results for one link, 
and that's because every student gets their own grade. 
Okay, so this just happens to be the data model for 
this piece of software you have now been using, perhaps, for several months. 
But you see one of these many-to-many relationships.
Play video starting at :14:58 and follow transcript14:58
Okay. So, why did we do all this? 
Why did we do all of these things? 
Why did we make these little integers? Why did we take you about JOIN? 
Why did we teach about many-to-many? 
Why did we make your data look so crazy? And that is all about speed. 
And you might say I don't care about speed.
Play video starting at :15:20 and follow transcript15:20
And it turns out that there are plenty of programs for 
which you don't care about speed. 
You know, the little program to calculate the US floor from 
the Europe floor. 
It doesn't matter. 
Reading 10,000 lines from a file doesn't matter. But when you build a SAN online 
application or even a large data analysis application, speed begins to matter. 
And so what happens is you cross over this moment where it become too slow. 
And then the only way to make it go fast is to really make it go fast. 
And so when you use databases you can do things that seem amazingly fast. 
And so all this normalization, the amount of data that you store, 
the amount of data you scan, is really taken out. 
And it's not really a trade-off. 
Either your thing is small enough that you don't have to do this, or you cross over 
this point where your application will fail unless you don't do this. 
And so that's why 
this is an important skill to have.
Play video starting at :16:10 and follow transcript16:10
So, we've covered a lot of SQL in a short period of time. 
There's much more to learn. 
People always ask me, is there an advanced SQL class, and 
I'm like, well it's kind of a beginning SQL class and then the rest of your life. 
Because you can always learn more about Structured Query Language, and 
how databases work, and what goes fast, and what doesn't go fast. 
A couple things that you can look for 
as topics that we really didn't cover very well. 
Indexes, this has to do with like logical keys and lookups really fast for strings. 
Constraints. 
We did have a thing not null. 
There's other constraints that you can put on data. 
And transactions. 
They're a way to group operations, like if a read starts, 
no more reads until a write happens. 
And so it's a way of blocking things, and so these are all very, very important topics. 
And so, relational databases could be a profession all by itself. 
Just knowing how to do databases is impressive. 
Doing database design is impressive. 
And I hope this has gotten you to the point where you can somewhat 
understand what's going on, and then, learn the rest of your life. 
Okay? 
See you.

Hello and welcome to our code walk through on the roster code. 
The learning objective of this is to do a many-to-many table, 
and so the idea is that we're going to, just like we talked about in lecture, 
we're going to have a set of users, 
we're going to set of courses, 
and then we're going to have a connector table or 
a many-to-many table that basically has two foreign keys. 
We are going to use the integer not null primary key auto increment unique 
as the way to get auto assignment of 
the primary keys in the user table and the course table. 
And then, we're going to say that the name, which is 
like a logical key, and then the course title, 
we're going to mark those as unique. 
And we're going to take advantage of that in a moment. 
And so you'll see how we take advantage of that. 
What unique means is if you try to insert the same string into this column, 
you know like chuck twice, 
then it's going to fail the second time because it's going to 
refuse to create a new record. 
And so if we just kind of like take a look, 
we're going to get our roster data from this sample JSON, 
which is just an array of arrays. 
And this is the person's name, 
the class that they're in, 
and whether they are a teacher or a student. 
And so we're going to read that. 
We need the JSON library and the SQLite library. 
We make a database connection and we get a cursor. 
The cursor is the kind of more like the file handle. 
You send SQL commands to the cursor and then you read the cursor to get the data back. 
The connection can create 
more than one cursor too so you can add more than one set of commands. 
But the cursor is generally like the file handle to the database server. 
And we are going to execute a big script and 
you'll notice this is a triple-quoted string that goes all the way down to here. 
Some people would just give this to you in a text file and have you cut and paste this, 
and then go run that in your SQLite browser to create them. 
But that's okay because what we're going to do is we're going to set this up. 
It will either reconnect to existing file name rosterdb.sqlite. 
And if I look where I'm at and I do an ls, 
we find that that file is not there. 
So the first time I run it it's going to create it, 
but I want this to start fresh every time, 
so I'm going to wipe out the tables if they exist. 
That way you can run it over, and over, 
and over again, in case you make a mistake here. 
Now, I don't have a mistake, or hopefully I don't have a mistake on this. 
So we're going to create, 
we're going to drop three tables and we're going to create three tables. 
And here, we're going to create the table that has two foreign keys, user_id, course_id, 
that are sort of going outwards from the member table. 
And then, we're going to model a little bit of the data at the role. 
Again, this is straight from the lecture. 
And the primary key is actually a composite primary key because we're going to 
look up and it's going to force this to be 
the combination of user_id and course_id to be unique. 
But there can be many user IDs and many course IDs, 
but only one particular combination of a value for user_id and course_id. 
And so that's what we're basically saying. 
You can be a member of a course, 
but you can only do that once. 
You can't be like a member of the course a bunch of times. 
We're going to, that should be roster_data_sample. 
That's okay. Oops. Fix a bug. 
Save that, roster_data_sample. 
And so that's just this file. 
It's really just an array and then each row is an array. 
And it's a way for us to get this roster data in. 
Once we do loads on JSON, we're parsing it. 
And then, this is going to be an array of arrays. 
for entry in JSON data, 
so entry is going to be one of these things. 
So entry itself is a row. 
So and entry sub zero is the name and entry sub one is the title. 
Name, that's the sub zero and that's the sub one of 
the particular entry that we're looking at. 
And we're going to print it out just for yucks as a tuple. 
So we make, that's what the two parentheses are. 
This inner thing is a two-tuple. 
And we're then going to take the person, 
and we're going to do an insert, and this is new, or ignore. 
So what the or ignore means is if this insert would cause an error, 
please don't blow up. 
Don't, just ignore that I try to insert it. 
And so this is our trick and it's a beautiful trick. 
It's like a gorgeously beautiful trick. 
Here, if we insert the name Chuck twice, or ignore will just mean that nothing happens. 
Meaning it's already there. 
Okay, so if it's already there. 
If it's not there, it'll put it in. 
And the unique will guarantee that it only goes in once. 
So we just in effect 
always attempt to insert it. 
If it's had been there once, 
then it's all set. 
And so this insert or ignore is a super powerful mechanism. 
I use it all the time. 
And we have a placeholder in the form of a question mark. 
And then we have 
so one of these days we'll have two things that we're asking for. 
As matter of fact, here it is, 
there's a tuple down here. 
But this is kind of a tuple with one item in it, name. 
And that name is then going to substitute in for there without, 
while avoiding SQL injection. 
So this runs. It may or may not insert a new record, 
but if it's Chuck or whomever that name is not there, 
it will give us a new record. 
And then we are going to get back the ID. 
And so this is the logical key and this is the primary key. 
That primary key is going to be auto constructed for us. 
So we need to know what it is. 
So we say select id from user where name equals and then that same name. 
So that's Chuck. And so that gives us one. 
And then, what we do is we're going to fetch one record from the cursor, 
cause that's a select and it gives us back a cursor. 
There's only, hopefully, one record there because it's unique. 
I could put a limit 1 in there but that would be kind of 
redundant because it is, name is a unique key. 
And then, the sub zero just means if there were more than one thing that I was selecting, 
which you'll see in a bit, 
the sub zero is just the first thing. 
And so this is going to give us the integer, 
user_id, that was assigned, 
or if we're coming through later for Chuck, 
Chuck later, Charlie later, 
that will be the old one. 
So this is inserted if it doesn't exist, 
and this is get the newly created ID field or the original ID field. 
Part of this works by having both a logical key and a primary key. 
The primary key is auto generated, 
but the name is a logical key and it's unique and so that's 
our trick to get that assigned thing. 
Before we just looked at it in the user interface of SQLite browser and wrote it down, 
but this is how we do it in code. 
So we need to know what that key is, 
whether it was new or not. 
And then, we do the exact same pattern for 
the course except we're inserting the course title. 
So that's no big deal. 
We're going to get the user_id, course_id. 
And then what we're going to do is we are going to insert or replace. 
This is, it basically if there, 
remember that this user_id, course_id, 
combination is the primary key for this member table. 
If there is a duplicate, 
if this combination is already there, 
this becomes effectively an update state. 
And we have these two number values. 
Now what's missing here is the role is not there. 
And so user_id, 
course_id, this is the SQL bit. 
And now we have a tuple with two items in it and that's 
because we have two question marks. And then we commit it. 
And as I mentioned before, 
sometimes you want to commit every time through the commit. 
It turns out that these things are less costly, 
but that's because it's not always writing all the way to disk. 
Whereas, when you enter the commit, 
it's going to go and write everything to disk, 
pause until it's complete, 
and then your program doesn't continue. 
So sometimes we don't run this every single time through. Okay? 
So let's just go ahead and run this. 
The only thing we're going to see is the output of 
the name and the title as it's running. 
So python3 roster.py. 
Hopefully, I can hit enter. So you'll notice, by 
the way, that this SQLite now exists, right? 
And it has no data in it. 
So let me see if I can open this database and see it. 
So you see that there is no data. 
So we're the code, 
we've run this code in effect up to this point. 
So we've done all the create tables and all that stuff. 
So the create tables are there. 
So all this data is here, it did it. 
We haven't started putting any data into it yet because if we look at browse data, 
we're not finding anything in here. Okay? 
There's no data to browse. 
Now, hopefully we won't have locked ourselves because we are sitting right here. 
And when I hit enter over here, 
then it's going to go and it's going to run really fast. 
So I hit enter, 
it'll read it, and so it inserted all of those things. 
And now it's been changed. 
And if I hit refresh over here, 
we will see in the user, 
it just sort of assigned user IDs, 
right? Columns auto assigned. 
We will find in the course that those courses are all auto assigned. 
There's the courses. And there's no duplicates because this is unique, right? 
And so these are the newly created things. 
But then, membership is user_id, course_id. 
And so again, the primary key as it were 
the unique constraints as primary key is the combination of these things. 
And I haven't put anything in role. 
And so if you scroll through these, 
you see all of the users who are members of the courses that they're part of. Okay? 
So there you go. 
And I'll leave it up to you to come up with the join. 
I'll leave it up to you to figure out how to put the role in. 
But I just wanted to kind of give you a bit of 
a walk through this code base and in particular, 
the tricks of the uniqueness keys, 
the auto increment keys, 
the logical key uniqueness, 
and then this kind of composite primary key, 
and then the trick of insert or ignore, 
and then the quick select that comes right afterwards to get 
the newly generated ID or to get the old ID. 
And then insert or replace which is a combination of a insert and an update. 
I hope you found this example useful, 
and can apply it, 
and basically create many-to-many tables.

### Many Students in Many Courses
This assignment will be a Python program to build a set of tables using the Many-to-Many approach to store enrollment and role data.
________________________________________
This course uses a third-party app, Many Students in Many Courses, to enhance your learning experience. The app will reference basic information like your name, email, and Coursera ID.
Coursera Honor Code  Learn more
 
I, elham fazel, understand that submitting work that isn’t my own may result in permanent failure of this course or deactivation of my Coursera account.
[NOISE] Hello. 
This is Chuck. 
And I'm here in Mexico City with yet 
another Coursera Office Hours face to face. 
And I'd like to introduce you to some of your fellow students. 
So tell us your name. 
Let me get set up here. 
Tell us your name and say hi or whatever else you want to say. 
>> Hi, I'm Mugo. 
I'm very happy to be here meeting Doctor Chuck and other fellow students. 
>> Cool. 
>> [INAUDIBLE] I'm really having fun with Doctor Chuck, 
and it's great that he can be here in Mexico City so. 
>> Hi I'm my first time in Coursera, and I'm very thankful with Doctor Chuck, 
and happy to meet some of my fellow students.
Play video starting at ::44 and follow transcript0:44
>> Hi everybody. 
I'm Eric, and I am too happy to meet Dr. Chuck.
Play video starting at ::50 and follow transcript0:50
>> Hi, my name is Anna, and the lecture is great! 
[LAUGH] >> [LAUGH]
We were an early adopter of Version 6 Unix here and we had a VAX and PDP-11s and 
all the stuff. 
And so we were happy to run Unix and 
I was teaching a course on operating systems using Version 6 Unix. 
And John Lions of Australia wrote a little book sort of 
describing it line by line and it was very popular at universities. 
And the bean counters at AT&T decided this was a bad idea. That having 
every student in the world learn about their product, 
which they owned, they thought was a horrible idea. 
So the Version 7 came with a license saying, thou shalt not teach. 
Okay, so the Version 7 license was you couldn't teach Version 7 Unix anymore, 
which was, it's gotta be up there, ranking up there with 
something Xerox did as the dumbest mistake of all of history. 
But, they did that. 
So, we couldn't teach Unix anymore. 
I said, maybe I'll write my own operating system which is compatible with V7, 
then I can teach it. 
I sat down and I began writing. 
It sort of worked, I got it almost to the point where it worked. 
And it was crashing at random. All of the functionality was there and 
it would run for 15 minutes and then it would crash. 
I was like about to give up, I just couldn't, so I said what i'll do, 
i'll write a simulator 
for the PC and I'll run on the simulator because that's entirely deterministic and 
reproducible, and then after it crashes I can go run it again and 
print out the last 100,000 instructions and find out what happened. 
So I wrote the simulator, it took me a little while but I got it running, so I had 
a complete simulator for the PC. If I'd been smart I would have invented VMware. 
This is in the '80s because I already done the basic work I could have done translation 
instead of interpretation. 
So I wrote a PC simulator, anybody could do that. 
So I didn't care. 
So, it worked perfectly on the simulator. 
It would run forever. 
It wouldn't run on the hardware. 
It only ran on the simulator. 
And I'm kinda scratching my head from, gee, how come? 
One of my students Robert from NASA mentioned to me sort of, I was explaining 
this problem to him, mentioned me offhand. 
you know, when the Intel chip gets hot, it gives interrupt 15. 
I said, no it doesn't. 
He said, yeah, I heard that somewhere. 
I said, the manual doesn't mention anything about that. 
And so I said, well I don't know, I can put in the test. 
I wasn't catching interrupt 15, of course, because the manual didn't mention 
it existed. 
So I put in a little piece of code which caught interrupt 15. 
And sure enough, within an hour of running it I get this message. 
Hi, I'm interrupt 15. 
This is impossible, you'll never see this message. 
So I was saying all these very unpleasant things which I cannot repeat on the Internet 
about Intel. If they want to put a thermal sensor, great. 
Please put it in the manual, though, you know, mention it. 
So I put it in, and all of a sudden Minix worked, okay?
Play video starting at :2:46 and follow transcript2:46
If Robert hadn't made that comment there would have been no Minix. 
If there were no Minix there'd be no Linux. 
Because Linus went out and bought a PC specifically for 
the purpose of running Minix. 
He was in a Minix newsgroup. 
He had a big newsgroup on Usenet newsgroups. 
He spent a lot of time developing Linux based on Minix. 
He changed this. 
He changed that. 
And eventually he changed almost everything. 
And so it sort of launched as its own system. 
So if Robert hadn't made that comment there'd be no Minix, there'd be no Linux. 
If there'd been no Linux, there would have been no Android because the Android is Linux. 
Okay? And if there'd been no Android the relative stock prices of Samsung and 
Apple would have been quite different. 
Because the Apple is based on iOS, 
which is FreeBSD. which came from a whole different strain of Unix. 
So that wouldn't have been affected, by the presence or absence of Linux. 
But Robert's remark ultimately changed billions of dollars of valuation 
in the Samsung versus Apple stock prices. 
And if he hadn't made that, the world would be quite different. 
There probably wouldn't have been an Android. 
And, heaven knows all of the other things it depends on, Linux and Android. 
>> All the server bits of all of that, too. 
>> All the server parts, too. 
I mean, they may have been using FreeBSD or something instead, who knows? 
But that one little offhand remark had all these consequences downstream. 
>> So then, how did you, did you write Minix and then write the book? 
>> So anyway, yeah, I wrote Minix and then I wanted to document it. 
Because I wanted something like Lion's book, which explained in a course. 
Most of the chapters have three sections, 
one is the general principles of file systems or process management or 
whatever, the second part is how these general principles apply to Minix. 
What is the memory management algorithm, 
how's the file system organized, what are the key data structures, and so on. 
The third part of every chapter is, now we're going to look at the code. 
Here online 10,720, we see the main headers for the file system. 
Here we're declaring these headers. 
And now on line 14,000 we're starting with the actual main loop of the file system, 
and it goes and gets a request, and it takes it apart, there's a switch there, and 
it figures what to do. 
And, so it goes through the code bit by bit. 
So it was like Lion's code, and the book came with a bunch of floppy disks, 
which was the only transport medium in those days, 
where you actually had the source code. 
And so the book came out, it was an enormous success. 
And at the same time it was already BSD, which was a mature, 
stable, working system which had 20 years of background, the VAX and 
the PDP-11, and the guys who formed it, McCusick and so on, they formed a company 
BSD incorporated, and they were trying to sell it commercially. 
And their phone number was 1 800 it's Unix and so what does AT&T do? 
Again, in one of the more brilliant commercial moves in all of history, 
they sued BSDI to get rid of them. 
And they had no knowledge at all of how to sell Unix. 
If anybody ever had had an IQ above about, you know, two-digit numbers, 
they would have gone to the BSDI guys and say, we want to buy your company, how much? 
And given you're AT&T, the biggest corporation in the world, 
no matter what number they mentioned, they would have said good, sign here. 
And they would have had the BSDI guys sell Unix. 
There would have been no MS DOS, there would have been be no Windows. 
It would have been all Unix. 
And they tried to stop these guys. 
So BSD was blocked from going commercial and I knew about this. 
And so I didn't want to make Minix like a big commercial thing because 
I figured the BSD guys were eventually are going to go out there and it's 
a stable mature system with many programmers, and 
many users, and all software. 
that would take over the commercial aspect of this free software world. 
But it didn't because of the stupid lawsuit from AT&T. 
And so that was the interval that Linux got a chance to grow. 
So again, one of those freaky. 
The bean counters at A&T who sued these guys instead of buying the company and 
saying you're our marketing division, go sell it.
Play video starting at :6:25 and follow transcript6:25
>> But at the same time, if you think about Minix, the Linux movement 
let Minux stay for teaching and education. 
>> For a while. Yeah. 
We've changed that recently. 
>> Okay. >> I got one of these, the European Union, 
they decided to set up a couple of new programs where basically, 
they would give a large chunk of money, about two and a half million Euro, which is 
I don't know, three and a half or four million dollars, to one specific investigator. 
There's two categories, 
young investigators who are sort of getting started, and 
senior ones with a track record, and basically let them go do their thing. 
And I applied for this, and I got one of them. 
And with this ERC advance grant, we're trying to go commercial with Minix. 
We're pushing it in the area of embedded systems and high reliability 
because it's got a kernel and 
all these servers that run separately in user spaces, user mode processes. 
And in particular, if one of them crashes, 
there's a reasonable chance we can repair it on the fly 
without disturbing running programs. 
And so 
if the disk driver fails, we can detect that, we can start up another disk driver. 
And there's a glitch of a couple hundred milliseconds while we're 
restarting things. 
But things go on. 
If the disk driver in Linux crashes, that's the end of Linux, okay? 
You have to reboot the whole computer. 
So we think there might be a little niche in there. 
>> I think there's a significant niche actually. 
I think that the problem with modern operating systems is they're 
getting too large and too complex >> Yeah this breaks up the little pieces. 
And another thing which we can do now, 
just before you started one of my PhD students came in. He's working on live update. 
So we can update almost all of the operating system on the fly, 
from version 3.3 to version 3.4, which might have thousands of changes, 
including data structures, 
on the fly, while the system is running, while application programs are running, 
without changing or stopping or interfering with the running programs. 
And this is tricky. 
The model, of course, is that the person who wrote version 3.4 
was keenly aware of all the details of 3.3. 
So if there was some internal table, like say the mount table, which was, say, 
a linear list in 3.3, and he decided to make it a hash table in 3.4 because 
you could have a lot of things mounted, then he'd have to write the code for 
converting one data structure to the other. 
But basically, you say I want to do an update and 
there's a manager which handles that, and the manager goes to the old one and 
says okay, finish off what you're doing now, don't take on any more work. Queue it. 
And then when you're all done, let me know. And when it's done then the manager starts up 
the new one. 
The new one then goes to the old one and 
says okay, I need all your data structures. 
And the LLVM compiler allows us to record 
in memory all the data structures very nicely, their types and locations. 
So it says to them give me your first data structure. 
And it gets the first data structure, see if it's identical to the old one, 
if so, just copies it. 
If not, it's got to run a routine to do a conversion from, say, 
a linear table to a hash table or a list or whatever the new one is, it runs that. 
When it's all done the whole thing is converted. 
Okay, it doesn't take very long, computers are good at that. 
And then when it's all finished, it tells the manager, okay I'm ready to go live. 
The manager then changes all the internal connections to point to the new one, 
makes the new one go live, kills off the old one. 
And there you go and there's a slight glitch 
of maybe a couple of hundred milliseconds for the application 
when there was no file service but they don't know that, 
unless you're doing hard real time, everything works. 
And we think that might be interesting for applications that never want to go down. 
And they know that softwares change all the time, and there are security fixes. 
And we're focusing this on the embedded world where we think there's a lot of 
interest in keeping the thing running all the time. 
If you're running some real-time system, whether it's a radio telescope, 
or an electric power plant, or some other real-time thing, 
you may not want to go down for reboots once in a while. 
And so a system which can update itself, which can repair itself, which can try and 
have a fairly high availability might have a niche in there. 
We've got it working in the lab now for the BeagleBoard, for the BeagleBone. 
We're about to release it for 
the Beagle Black also, which is like the Raspberry Pi but even better.
Play video starting at :10:24 and follow transcript10:24
So we're sort of trying to see if we can find a niche there. 
[MUSIC]

Hello everybody. Welcome to Python for Everybody. 
We are doing some code walk-throughs. 
If you want to follow along with the code, 
you can download the source code from Python for Everybody website. 
So, the code we're playing with today is twfriends.py. 
This is a step beyond the simple twspider. 
It is a restartable spider. 
But we're going to date the model things a little bit differently. 
We're going to have two tables and we're going to have 
a many-to-many relationship accepted. 
It's a many-to-many relationship between the same table, which is okay. 
Twitter friends are a directional relationship. 
So, we start out here in twfriends.py. 
Remember, that the file hidden.py, 
I'll show it to you, 
but I'm not going to open it because I've got my keys and secrets in it. 
So, this hidden.py file, 
you've got to edit that, 
and you got to go to apps.twitter.com and get your keys and put them in there. 
Otherwise, these things won't work. 
But if you have Twitter and you set your API keys up, 
and you put them in the hidden.py, 
then all these things will work. 
It's fun actually, and impressive. 
Not hard to do actually.
Play video starting at :1:25 and follow transcript1:25
So, the Twitter URL, that's my library, 
that reads hidden.py and augments the URL does all the OAuth stuff, 
JSON and SSL because 
Python doesn't accept any certificates even if they're good certificates. 
So, we crush that. 
Here's our friends list that we're going to hit. 
We're going to make a database friends.sqlite. 
Now, here we're doing a create table if not exists. 
So, what this really is saying is, 
I want this to be a restartable process and I don't want to lose the data. 
We're starting out, we do not have any SQLite files. 
So, this is going to create the database and create these tables. 
But the second time we run it, 
we're not going to recreate the tables. 
We're not going to be able to restart this, 
because we're going to run out of rate limit before we finish this. 
So, we just have to wait, 
however long the time it takes to reset, 
and we'll watch the rate limit go down. 
So, we're going to have a people table, 
and we're going to have a primary key and the name. 
The name is going to be unique, 
and whether or not we've retrieved it. 
That's from a previous one. 
Then there's the who follows who, 
the from ID to, to ID. 
So, this is a direction and we're going to put a uniqueness constraint in, 
just like we do in many-to-many, that basically says, 
the combination of from ID and to ID has got to be unique. 
We don't allow ourselves to put duplicates of the combination. 
So, from ID can be one in many records, 
and to ID can be one in many records, 
but one, one is only allowed once. 
This is the crud we have to do to convince Python to accept the Twitter certificate. 
So, this is similar to some of the other stuff that we've done. 
We're going to enter a Twitter account or quit. 
If we enter by itself, 
then we will actually go and retrieve a record that was not yet retrieved. 
Now, we're actually pulling out two values, ID and name. 
So, we will grab, 
fetch one, is going to give us a two tuple basically. 
We're going to store that in ID, in account. 
Of course, that's like, this is coming back with a two tuple, 
first of which is the ID from the database. 
Limit one, means we're only going get one of these or zero of these. 
If there's zero these, 
that means there are no unretrieved Twitter accounts. 
Retrieved equals zero, well, you'll see in a second, 
that all the new accounts we put in, 
are the ones for which we haven't retrieved. 
Again, given that our rate limit, 
we want to know which ones we've retrieved. 
Okay? So, what we're going do next is, 
we're going to check to see if the person that we just checked, 
which means the length of the account is greater than what we just entered. 
We're going to check to see if they're already there. 
Okay? We're going to select ID from people where name equals. 
So, that's the one we just entered. 
We're going to fetch one and grab the first thing, 
because we only got one thing in the select statement here. 
If this person that we just asked to see is not in the table, 
that means this is going to fail, 
we're going to do an insert or ignore. 
This our ignore is redundant because we just checked to see if it was there. 
But we'll put that in just to be safe. 
We're going to put the name in as the new account that we're looking at, 
indicating that retrieved is zero. 
So, that we will know that we haven't retrieved it yet. 
You'll see that we'll update that in a second. 
We commit it, so that later selects we'll see this. 
So, you got to do the commit. 
This later select wouldn't see the one we just inserted. 
We're going to ask how many rows were affected, 
and if it's not equal to one, then, 
we're going to complain about- we inserted it, 
and we're going to do this thing. 
We are going to ask, "Hey remember there was an ID up there?" 
Right here, ID integer, primary key, 
and we did not insert this here, 
but we want to know what that ID is. 
Every time I was showing you that in lectures, 
I was saying it's really easy in Python to do this. 
That's what we're saying. 
This cursor did the insert, 
but one of the things happens is after the insert, 
we're going to grab the last row ID, 
which is the primary key that was assigned by SQL. 
Okay? So, that means, that one way or another, 
coming through this code here in line 45, one way or another, 
we're either going to know the ID of the user that was there before, 
or we just inserted one and so we're going to know the primary key of the current user. 
You'll see why we need that. 
So, ID, is the primary key of the current user that we entered right here. 
Okay? Now, what we're going to do is do the Twitter URL augment with OAuth, 
and all the keys, and the secrets in hidden.py. 
Instead, we're going go through let's count 1,000. 
Let's go count, what the heck. 
Let's go 200. 
Up to 200 friends. 
No, let's do 100. We'll keep it that way. 
Then, we're going to retrieve it and we're retrieving the account. 
We're not going to print the nasty URL out, we could. 
Then we're going open the URL with a connection, 
and then we're going to read that, 
and we're going get the UTF-8 data from this, 
and then we're going to decode that, 
and we're going to have the unicode data. 
So, the data in string is a internal Python string, 
with all that data representing all the wonderful characters. 
Of course, we're going to ask URL open to give us back 
the headers as a dictionary, using this call. 
We can see how many we have left for the remaining. 
Right? What's the remaining rate limit that we have? 
So, then we're going to parse the data with JSON load S. Wait, 
I need to continue in here. 
Continue. Okay. Save. 
If we're going to parse this data, 
we'll print it out, right? 
So, that means that this died, 
which means it's not syntactically correct, json basically. 
Who knows if we're ever going to see that, 
but at least, when it blows up it'll print this data out. 
We'll have to catch it, and then it'll continue. 
Actually, I'll make this a break, 
because if that's blown up that bad, we should quit. 
Now, I don't yet know what happens when this rate limit says you can't have it, 
and so but I do know that I expect when it's successful, 
that there will be a key of users in this outer dictionary that we're going to get. 
If this outer dictionary, 
that if users is not in the parsed dictionary, 
then I'm going to dump out this data so that at least I can 
debug what happens when I've got some broken json. 
So, the difference between this code, 
this code is going to fail when the json is syntactically bad, 
meaning a curly brace isn't right or whatever. 
This code will trigger when I get good json, 
but I don't have a user's key in it, okay? 
So, then, once we've retrieved it, 
we will be pretty happy with it. 
We're going to update for our account that we're retrieving. 
We're going to set this is one of our retrieved accounts, okay? 
Then, what we're going to do is write a loop that goes through 
all the friends of this particular user that we're asking, 
and gets their screen name, 
prints it out, and then we're going to check to 
see if this one is already in our people database, 
because this is a spider, we're grabbing accounts. 
So, we'll do a friend ID, 
and do a fetch one, 
grab the subzero thing. 
If that works, if this person not in there, 
this fetch one is going to blow up which 
means we're going to drop down to the except code. 
But if it does work, we have friend ID, 
that if they're there, 
and they're already in our database. 
They just weren't retrieved. 
Okay. So now, if the friend ID wasn't there, 
we're going to do an insert into, 
setting retrieved to zero, 
and then we're going to commit. 
Now, remember, row count is 
how many rows were affected by this last transaction code at row count, 
and we're going to die if that insert doesn't work. 
This is unlikely, unless somehow we've ran out a disc drive or something, 
and we're going to grab the friend ID as the key, 
the last row that was inserted. 
We're only going insert one row, 
so it's basically the primary key of the row that we just inserted. 
So, if you look at this code right here, 
it comes out the bottom, 
one way or another with friend ID successful. 
Friend ID is either they are already in our database or they're not, 
and if we insert them, 
then we have it. 
So now, this count new and count old is just so I can print out a nice print out. 
Now, we are going to insert into 
the friend's table which is called the follows table in this case, 
from ID and to ID. 
Those are the two outward pointing foreign keys, 
and we have the ID of the account that we're retrieving the friends of, 
and then this particular friend. 
So, we're inserting the connection from this person to that person then we commit it. 
We want to commit these again so that later selects when the loop goes back up, 
later selects get all of that data that's going on. 
So, we do want to commit from time to time, 
and then we close the cursor at the very end. 
So, let's run this and see what happens. 
So, python twfriends.py. Of course, 
I am a refugee from python two, 
so I always forget to type python three. 
So, we're going to start. If we take a look right now, 
I'm going to start another tab over here, and ls-l *sqlite. 
Now, that sqlite file is there, 
and it's actually made the tables. 
If you go up here, it ran all this stuff, 
create the tables, yada, yada, 
and we're sitting right here at this line. 
As a matter of fact, I think without causing too much trouble, 
I can open that database, 
and get into this database right here. 
There is no data in the Follows table, 
and there is no data in the People table. 
It's completely empty. 
So, we're waiting for the first one, 
and I'll go with mine, Doctor Chuck. 
So, it's retrieving the 100 friends, 
and they all were brand new. 
They are all inserted. 
So now, if I hit Refresh, 
we will see that Doctor Chuck is retrieved. Who follows? 
So, these are all the people I follow, 
for one follows two. 
So, if we look at here, we see that Doctor Chuck follows Stephanie Teasley. 
Because we grabbed the followers of Dr. Chuck, 
we're going to have a record in all of the follows for all the ones that I did, right? 
So, these are all the people I followed, 
and we put them in. 
So, we can go back and we can, 
let's see grab somebody. 
Let's go grab Stephanie Teasley, 
and let's pull out her friends. 
So, we grabbed 100 of her folks. 
I got 14 left. 
That's my x-rate limit. 
I did Stephanie Teasley, 
so let's go back here. 
So, you'll notice there's 101, 
that row is going to be 182. That's interesting. 
So, we've retrieved Doctor Chuck and Stephanie Teasley, 
and let's go take a look in the Friends table, the Follows table. 
So, we have all the people I follow, 
now all the people Stephanie follows. 
So, there we go. 
Let's go ahead and do somebody else. Let's see here. 
I think we both follow Tim McKay. 
Where is Tim McKay?
Play video starting at :13:37 and follow transcript13:37
Let's follow Tim McKay. Let's see who to Tim follows, 
If we can get like an overlap. 
We revisited some. 
Let's see if we can see this in the Follows.
Play video starting at :13:51 and follow transcript13:51
Let's see People. 
So, we've got Dr. Chuck retrieved. 
Tim McKay's somewhere down here.
Play video starting at :14:3 and follow transcript14:03
It might take us a while before we get any really good overlaps. Let's see. 
Let's do a database called. Let's see. 
Let's do a database SQL.
Play video starting at :14:21 and follow transcript14:21
Select, count. 
Yeah.
Play video starting at :14:37 and follow transcript14:37
Okay. So, let's just run this some more. It's clearly working. 
Now, one thing I can do here is I can hit "Enter", 
and it will just pick one randomly. 
So, it grabbed Liveedutv. 
Let's see how many I got left. 
We got 12 left. 
Now, I can hit "Enter" again. 
It picks another one. 
That was the next one. 
It's picking them in order. Is it picking them in order? 
Let's go to "People". Yeah, it's picking these. 
So, we can see that it's going to just do the first unretrieved person, who's Nancy. 
Let it retrieve Nancy. 
So, it grabbed Nancy, new. 
So, we're finding some and this table's getting really big. 
So, if we look at the "People" table, 
we now have 455 people and we have 467 following records. 
So, there we go. Hit "Enter", 
does another one, and away we go. 
So, you get the idea. 
I can type quit to finish. 
Just to give you a little interesting bit of code to show you how to do selects, 
I'm going to do this twjoin. 
Now, you'll notice that we're not talking, let's show you one thing, 
ls minus l star sqlite. 
So, this database has it. 
So, I can restart this process and run it again. 
The database is still there. 
So, we just grab, swear_trek. 
So, we can keep doing this. 
So, this data, it keeps extending. 
So, this is a restartable process. 
I can run it. Then, tell it to grab the next unretrieved one. 
So, away we go.
Play video starting at :16:31 and follow transcript16:31
So, that's part of it.
Play video starting at :16:36 and follow transcript16:36
I've got eight left. How many do I have left, 
really? Let's keep going. 
How many do I got left? I got five left. 
Okay. Wait, I guess we'll just run it out. 
So, I got four left. 
You know what I should do? I can't change the code. 
Yes, I can change the code. 
I can stop the code and I can quit the code. 
So, what I'm going to do is I'm going to change this code a little bit really 
quick and I'm going to print the headers 
of rate limiting at the beginning and at the end.
Play video starting at :17:17 and follow transcript17:17
So, now I can run it again. I changed the code. 
Hopefully, I didn't make a Python error. 
Tell it to go get another one, 
Ana Navarro. So, I got three left.
Play video starting at :17:28 and follow transcript17:28
We'll see what happens when I run out of rate limit. 
Run out of rate limit. So, we have one left. 
Hit "Enter" and control K, OpenSource.org. 
So, we have zero left, that worked. 
Now, let's see what happens. 
I don't know what happens next. 
We blew up. Too many requests. 
So, we got a HTTP Error 429. 
So, that means that going from Marc Cuban, 
that was in line 48, so the right thing to do would be in line 48.
Play video starting at :18:10 and follow transcript18:10
We should really put this in a "try except" block. 
"try except" block because it gives us an error.
Play video starting at :18:25 and follow transcript18:25
Print, fiddlesticks. 
How do I print the exception message? 
I always am forgetting. 
Print "Failed to Retrieve".
Play video starting at :18:39 and follow transcript18:39
So, we'll put that in. 
Now, if I run it.
Play video starting at :18:47 and follow transcript18:47
Then, I have to put a "break" here because that's not good. 
Break. Fail to Retrieve. 
See, I never know how to print out the error message. 
Yeah. So, see that's the weird thing about stuff is, 
that I don't ever remember enough. 
I don't remember the syntax, 
what I say here, 
to print the error message out. 
So, I'm going to go to Google and I'm going to say, 
"Print out the exception message in Python."
Play video starting at :19:36 and follow transcript19:36
Python 3, hello.
Play video starting at :19:44 and follow transcript19:44
So, let's go find it here in the documentation.
Play video starting at :19:52 and follow transcript19:52
Except. Is this it? 
Is this what I say?
Play video starting at :20:14 and follow transcript20:14
I just want to print out the message.
Play video starting at :20:20 and follow transcript20:20
That's it. Except. Let's try this.
Play video starting at :20:41 and follow transcript20:41
So, this is part of Python programming is, 
for me at least, because I'm just not a genius expert at this stuff. 
This is one thing I like about 
Python is you can guess stuff and sometimes you guess right. So, there we go. 
We got the error, we got the nice little error message, 
and we see error 429: Too Many Requests. 
So, that cleans that up nicely. 
So, we have run out of requests. 
On that, it is a good time to say thanks for listening. 
I hope that you found this valuable.

Welcome to Chapter 15. 
We're going to have a little bit of a different take on Chapter 15. 
We're actually going to make more complex programs, and 
we're going to actually do multi-step programs in this chapter. 
And we're really just applying all of the skills that we 
gained in the first chapters. 
And if you don't understand this material, you really need to go back and 
review all those other chapters because we're going to start moving pretty fast. 
So what we're really going to work on is we're going to combine the act of working 
across the networks and we wrote a program that read some stuff off the network. 
We've done that. 
We've looked at databases and how Python programs can put stuff in databases. 
But now what we're going to do is we're going to use a database as 
an intermediate step and we're going to be gathering from some kind of a data source. 
Increasingly, data is found on the Web, often you find it in the wild. 
And you're doing something to, you're doing something, 
you're pulling something from a Twitter API like we did in the previous, or 
a GeoJSON API but then there's some rules about it. 
You might have to have an API key or you might have a rate limit or 
it might even be unreliable. 
And so you have this gathering process that basically says look, this is slow, 
yucky, unreliable, dangerous, and 
you might want to start this up and then restart it. 
This is a hard process. 
This might take hours of time. 
It might even take days and it might break and it might get fixed, right? 
And it might break and it might get fixed. And so this gathering process is something 
we want to be real careful, and that's why we tend to put the data in a database. 
Because databases are really good at sort of not losing data and 
you're halfway through, and something blows up, 
the data you have is in the database. 
And so the gathering, in many ways, it'll be like, okay how much data do I have? 
Now I'm going to go get some more data, put this in the database, oop, we blew up. 
So now we're going to run again, we're going to start up again. 
Okay, start up. Let's look at how much we got. 
We got more now. 
We're going to start at a different place looking at the data and 
we're going to gather that and add it on in the database. 
And we might have to do this many, many times. 
As I mention in the GeoJSON thing, because there's only 2500, 
it took me several days to get through 10,000 bits of data from the Geodata API. 
And what we tend to do is in this gathering process, 
we tend not to do any analysis of the data. 
We're just, like, we keep these programs relatively simple. 
They read something, they stick it in the database, read it, 
stick it in the database, 
deal with the fact that you've been blown up and have to start halfway through.
Play video starting at :2:37 and follow transcript2:37
So we keep these really very simple. And then we get our data and 
in here sometimes we'll have very raw data 
because we're really focusing this database on handling the complex 
management of the problems that you have while you're gathering the data. 
So at some point you've got your raw data and you may have a separate step 
that is a Python program that goes through and reads all the data in this database, 
runs a Python program, and might even run another database. 
And frankly, you could have more databases here, etc. 
But some process that basically reads the raw data. And 
then you might write another database. 
Some of these will just actually go straight to analysis or 
visualization in our earlier ones. 
But in later, what we'll do is have this pretty data, this is the clean data. 
This is the data that makes sense, right? 
It's the clean data. And then we're going to write another. 
So each one of these are Python program, 
Python program, and now we're going to run maybe couple other Python programs. 
This is going to read from the clean database and do some analysis and print us up some 
data or it might read from the clean database and then try to visualize the results. 
And so, these are separate steps and 
each of these boxes is a separate Python program. 
Now in a way, everything we've done up to this point has been 
write one Python program to produce some result, right? 
And we write a loop, and we read the stuff, and we make an array, and 
then we print the array out. 
But in this, because the problem is harder to solve and there's unreliability and 
other external things, we will basically break it into multiple steps. 
And we'll write a little Python program for each of these steps. 
Now what we're working on is not exactly data mining. It is and it isn't. 
I don't call this data mining, 
because that would be overstating what we're doing. 
There are many very complex data mining technologies and 
that's not what we're going to cover in this course. 
There are other places that you can learn about data mining and 
I'd like to think that our course that we're doing here is a good preparation for 
learning about data mining technology. 
So there's open source things like Hadoop and Spark. 
Amazon has a whole data mining operation called Redshift. 
And there's many community source, and then dot, dot, dot, dot, dot, dot, dot, 
dot, dot, dot. 
And so, don't assume that this is all there is to data mining. 
This is a particular style of data mining that I call "Personal Data Mining", right? 
And it is not to say that once you're done with this you're a data mining expert, 
because that would be a gross overstatement. 
We're really more interested in this chapter on making 
you better Python programmers 
by solving some simple rudimentary data mining problems with Python programs and 
then looking at those Python programs and becoming better Python programmers. 
So the first thing that we're going to do is we're going to build on something that we 
did in the last chapter, and that is talk to Google's Geocoding API. 
And pull some data into a database and then 
visualize something out of that database. And we're going to use the Google Maps API. 
So you do need to be connected to the Internet when you do this.
Play video starting at :5:33 and follow transcript5:33
And so, here we go, and of course, whenever you're doing any of these things, 
I will generally give you URLs to use other than the official URLs. 
You can use the official URLs, but at some point, we don't want them to get annoyed 
with so many students taking the class and pounding all of these APIs, 
I'll get some kind of email that says quit talking about our API. 
So I will, whenever possible, give you my own API to use for these kinds of things 
and I'll give you a whole video showing you these programs in action. 
But right now, 
I just want to show you the general outline of the picture of how these things work. 
And so we do have the Google Geodata API here. 
We have played with this before. And so if you look at this program, geoload.py, 
by the way, you download all this stuff from right there, and 
these are just files in there. 
geoload.py is a lot like the thing that you read before that reads some JSON, 
hits a URL, reads some JSON, parses some JSON, and 
then writes the JSON into a database, right? 
And this actually takes as a list of locations. 
So if you remember the other thing asking you for 
each location, this actually takes where.data, which is a list of locations. 
And this can have thousands or even hundreds of thousands of locations, and 
then as we retrieve each location, we put lines in our database. 
And this ends up in a file called geodata.sqlite. 
.sqlite is the suffix for SQL data.
Play video starting at :6:57 and follow transcript6:57
And so, this will run and this can start and stop, and start and stop. 
And remember this is only 2500 of these per day. 
Start and stop and slowly but surely, we build this up. 
Now the interesting thing is,
Play video starting at :7:9 and follow transcript7:09
even if you haven't got all the data you can still run these other things, 
because let's say you've got the first 500 of these records. 
Well, you can still make a pretty picture of 500 records and then later 
the next day you can then go get 500 more or 
1000 more depending on your network connection, etc., etc. 
And also don't get yourself in trouble with your network service provider 
by running these things 24 hours a day and downloading gigabytes of data, and 
all of a sudden you're on some mobile device, and so 
just be care how much data that you download. 
So at some point you have the data cached. 
We use the word cache, which is kind of a local copy of something that's elsewhere. 
So we've got a nice copy. So now we don't need to talk to Google any more. 
We've got all of our data sitting in this database, so 
we will write a little program called geodump.py 
And it will write a loop that's going to loop through all the records in this database, 
loop, loop, loop, loop, loop. 
And this one prints it out, just on the screen and it tells you, oh yeah, 
and I also wrote as a side effect 
a bunch of the data into a file called where.js 
This is a JavaScript file and you can take a look at it. 
This is not a JavaScript class. 
And what I've given you is I've given you a whole bunch of HTML and 
JavaScript that takes care of all this and this HTML file reads this JavaScript file. 
And then calls the Google API to make all the little dots on the map for you, right? 
And so if you in effect pull more data in, and then run this program, and 
then run the program, and 
then hit refresh on the screen, new little dots will start popping up. Okay? 
Now, the screen doesn't actually go straight to the database 
you have to run the geodump.py 
But now we're kind of seeing this multi-step process, where you do this for a while. 
You get your data filled up, and 
then you say oh I've got myself some nice raw data here 
that's been cached and now I'm going to run it. 
See what's going on and then I'll visualize it. Okay?
Play video starting at :8:58 and follow transcript8:58
Like I said, I'm not going to teach you 
in this class exactly how to write each one of these things, although in 
the Capstone some of you may play around a bit with doing those kinds of things. 
So this is the summary of our first of three 
examples of how we're going to do this personal data mining. 
So we'll see you in the next one where we'll talk about page rank algorithm.
So now, in this last chapter, 
we're going to talk a little bit about visualizing data. 
But what we're really doing is we're summing everything up, 
because we're going to retrieve data from the network, 
we're going to process the data, 
we're going to store it in a database, 
we're going to then write it out and visualize it. 
So, it's all coming together, 
and and it turns out that this notion of gathering data, 
the data gathering using the network it's pretty common thing. 
It might take a cleaning or processing step where we're- 
the part of the problem is when you're pulling data off the net, 
you want to be able to start this process because it'll run, and run, 
and then your computer will crash or it'll go to sleep or something. 
So, you don't want to start from the beginning 
because it might be quite a bit of data and 
it takes a while to do it or as we've seen in some, 
you might be talking to an API that's got some rate limit that says, oh, 
you'd have to stop at 14 of these things, 
or stop at 200 or whatever. 
So, this is often a restartable process and it's usually a simple process. 
It's usually a relatively small amount of code, 
where you have a queue of things you want to retrieve, 
you go to the next one and then you stored in database, 
next one starting database and when you start the process up, 
you start filling this database up with stuff and then if it blows up and you restart it, 
the first thing it does is it reads the databases. 
"Oh, I don't need any of those", 
and then it starts to get the next one, 
and the next one, and the next one, and the next one. 
That is how you make this restartable. 
Databases are really good at having it, 
so that your program that's writing to the database can 
blow up and you don't corrupt your data. 
You don't have partial data, 
it's either written or it's not written and so these things can blow up in. 
Sometimes you just blow them up, 
because you want to blow them up and start them up, 
and you start them up again, 
they scan down, say, ''Where was I? 
Oh, I'll start here, here, here, here. '' 
So, this is often a slow and restartable process. 
It also might be limited but for some reason. 
So, this runs for awhile and the third thing we'll do in this chapter, 
it might run for days actually. 
Then, you have your data and then you start doing stuff inside 
your computer where you don't really care so much about the network, 
it might be this is raw data that came in off 
the APIs and you want to make the data in some new little format, 
so you might go from one database to another database or a database to 
a file and produced data that's really ready for visualization. 
If this might be a little complex or there might be flaws in it, 
you might write scanners that go like, "Oh, 
wait a sec, this is inconsistent, 
sometimes it looks like this and sometimes it looks like that, 
so I'll clean that stuff up." 
Then, using some visualization or doing some Python Programs that loop through the data 
once it's cleaned up and then do 
some summing or adding or who knows what they are that they're doing, 
but analyzing or visualizing. 
What we're going to use is we're going to use things like 
Google Maps to do our visualization, 
a lot of JavaScript and a thing called D3.js, 
which is a JavaScript library. 
Now, in this class, 
we're not teaching a JavaScript, 
we're not going teach you Google Maps. 
I provided all these things, 
so that when you run these programs, 
that stuff is all there. 
But if you want to learn and see some examples of how to make 
a little simple JavaScript visualization with a line or a word cloud or a map, 
we've got it, and you can take a look at those things. 
Now, this is one form of data mining and its really a data mining for an individual, 
where you're pulling this data, 
you're getting at local and then you're working with it there are 
other much more sophisticated data mining technologies 
that you might find yourself using. 
But often, you'll also find Python is part of these or Python helps you 
manage these or you write a Python Program to scan through 
these things or to prepare them or to do something. 
So, there's lots of different data mining technologies, 
this is just one oversimplified very Python-oriented data mining technology. 
I'd call this personal data mining. 
You should take classes. 
If you really want to become a Data Mining Expert, 
this is just giving you some of the skills that we've 
learned in this class and solving some data mining. 
So, the first application that we're going to data mine is 
an extension of an application we played with back in the JSON chapter. 
The idea is it has a Q of Locations. 
These are not pretty locations, 
meaning their user typed in your locations, 
they're actually from data from many years ago. 
It's anonymized data from the students who actually took one of my very first MOOCs, 
MOOC on Internet history, 
but it's reduced in anonymized just play with it. 
But it's not accurate. 
We don't have GPS coordinates. 
But if we use the Google GeoData API, 
but JSON we can do this, 
but we need to avoid rate limiting, 
so we're going to cache this in a database. 
Meaning, we're only going to retrieve data at once and then we're going to 
use the Google Maps API to visualize this in a browser. 
The sample code is right there and that sample code 
geodata.zip has a read me and it tells you exactly 
what to do to run this and it shouldn't be very 
hard for you to run it and produce a nice visual result. 
Here's a basic process diagram of what's going to happen, 
there is a list of the things to retrieve 
called where.data is just a list of the locations, 
but these are not correct, they don't have GPS, 
there just a as typed into a text field by a user and 
Geoload is going to start and start 
reading this and it checks to see if it's already in the database. 
This is a restartable process as I mentioned and then it 
looks to see the first unretrieved data and then it goes out and does a web service, 
parses that then puts it into the database and then goes to the next one, 
parses that puts it in a database and this 
runs for awhile and then maybe you blows up then 
you fix whatever or you start your computer backup and runs for a while. 
So, this is a restartable process that in effect is adding stuff to this database, 
it's an SQLite database and you can use the SQLite Browser 
to look at this if you like stuff we did in the database chapter. 
So, you can run that, you can see what you got, 
run at some more sewage which he got, 
debug it by using the SQLite Browser. 
Then at some point you've got all of your data and you want to 
you've got a couple of things we got this application 
called geodump.py that read 
through all of this data and then print some information out, nice summary information. 
It's really common to want to do this to get 
some summary information just for sanity checking, 
so you don't have to use SQLite Browser but this also 
writes out a little JavaScript file called 
where.js which then combined with where.html and the Google APIs.
Play video starting at :6:39 and follow transcript6:39
This uses JavaScript to put 
all these little pins on based on whatever data is in this database. 
So, that's our first end-to-end spider process visualize. 
First thing. So, up next, 
we're going to show how we can use this to build 
a very simple search engine and then run the PageRank algorithm.

Hello everybody, welcome to Python for Everybody. 
This is another work to code example. 
You can download the sample code zip file if you want to follow along. 
The code that we're working on today is what I call the geodata code, 
and that is code that is going to pull some locations from this file. 
We're simulating or using 
the Google places API to look places up and so we can visualize them on a map, 
and so this is the basic picture. 
If we take a look at this where.data file, 
it's just a flat file that has a list of organizations, 
and as actually was pulled from one of my Mooc surveys. 
We just let people type in where they went to school, 
and this is just a sample of them. 
So this data is read in by this program geoload.py, 
and if you recall, 
this Google geodata has great limits. 
It also has API keys which we'll talk about in a bit too. 
So the idea is, this is a restartable spider like process, 
and so we want to be able to run this and have it blow 
up and run it and start it and not lose what we've got. 
So this is unlike, some though, 
so we're not now using a database, 
as well as an API. 
But in order to work around the rate limits to this API, 
we're going to use the database with a restartable process. 
Then, we'll make some sense of this, 
and then we'll visualize this, 
but in the short-term, 
let's start with the geoload.py code. 
Geoload.py, take a look here. 
So, a lot of this hopefully by now is somewhat familiar to you, Urllib, json, sqlite. 
I mentioned, that the Google APIs, 
these used to be free and did not require an API key but increasingly, 
they're making you do API keys for especially new ones. 
So what happens, you can go to your Google places. 
I mean, go to Google APIs, 
and get an API key and you can put it in here. 
It'll be this long, big long thing, it looks like that. 
Then if you have an API key, 
you can use the places API. 
I've got a copy of a subset, 
not all of it, a subset of it here at this URL. 
As a matter of fact, you can just go to this URL in a browser,
Play video starting at :2:31 and follow transcript2:31
and it will tell you a list of the data that it knows about. 
I made it so that, that does the same basic protocol with 
the address equals as the Google places API. 
So, this will just change how we retrieve the data. 
Either retrieve it from my server, 
nice thing about my server, 
it's got no rate limit, 
it's really fast and you're not fighting with Google all the time. 
It means that perhaps, 
if you're in a country that Google is not well supported, 
you can use my API. 
I mean that's really strange, 
but somehow my API is more reliable and available than the Google one. 
But, it's true. So we're going to make a database. 
We're going to do a create table if not exists, 
and we'll have some address, 
and we're really just caching the geographical data. 
We're gonna cache the json. 
One of the things we do when we build these processes is we tend to simplify 
these things and not do all the calculation and parsing the json, 
just load it and get it in, 
and load it, and get it in. 
Fill the data up in this database, 
so that's what we're going to do. 
Because Python doesn't ship with any legitimate certificates, 
we have to sort of ignore certificate errors. 
We're going to open the file, we're going to loop through it, 
pull out the address from the file, 
and we're going to select from the geodata where that addresses the address. 
Let's move this in a bit. 
We're going to do a select, and pull out that address. 
The idea is as if it's already in the database we don't want to do it, 
so we do a fetch one and pull up that first thing that will be the json right there. 
If we get that, we'll continue up otherwise we'll keep going. 
Pass, just means don't blow up. 
So we accept and we just do a pass that's a no. 
We're going to make a dictionary, 
because that's what we do for the key-value pairs. 
Everything you've seen so far, I've used constants here, 
but because we may or may not have an API key, 
query equals and then that's the address and then the key equals and then the API key. 
If you recall URL encode adds the plusses, 
and question marks, and all that nice stuff. 
We're going to retrieve it, we're going to read it and decode it, 
print out how much data we've got and add account, 
and then we're going to try to parse that Json data and print it if something goes wrong. 
As we've seen at this top level of this json data from this Geocoding API is an object, 
which we'll see a little bit of it in a bit. 
It has a status field in it, 
and the status is okay, 
if things went well. 
If the status is not there, 
that means our JavaScript is not well formed, 
or not how we expect it. 
If the status is not okay, 
or not equals zero results, 
then print out failure to retrieve and then then quit. 
Then we're simply going to insert this new data that we just put in. 
Then we're gonna commit it, 
and every tenth one, 
this is count mod ten, 
we're going to pause for five seconds. 
We can hit control C here, 
and then we're going to do the geodump. 
So let's just run this, geodata, Python. 
So let's do an LS. 
So we do have, 
let's get rid of from a previous test geodata LS Sqllite. 
So we'll start with a fresh set of data, 
and run Python geoload.py. 
Of course, I'm always forever making the mistake of forgetting Python three, 
so you can see that it's running. 
It's adding the query and in this case I don't have the API key. 
It's putting the pluses in and that's this part here with all the pluses, 
that's the URL and code. 
You notice that it's pausing a bit, 
depends on how fast your net connection, 
this may or may not go so fast, 
but this is not that much data, so it should. 
It's like only 2,000 3,000 characters. 
So it's working and talking to my server. 
The interesting thing here is I can blow this up, 
I'm going to hit Control C.
Play video starting at :6:56 and follow transcript6:56
In Linux you'd hit Control C and on Windows I think you'd hit Control Z. 
Depending on which shell you're working in. 
But I'm going to hit Control C, and you see I sought blew it up. 
That causes a keyboard interrupt traceback. 
I do an LS minus L, 
you can see that now there's Geodata is there. 
Now, in the name of restarting, 
I will restart this. 
You will see that it checks, 
and skips and so it runs this code here, 
where it's right here. 
It grabs it, and finds it in the database. 
So you'll see it's found in the database really quick, 
chop, chop, chop and go really fast. 
Then it'll go back to catching up where it left off. 
So all those up there, 
they did not actually re-retrieve it, 
because it knew about those things. 
Now it's catching up, 
and doing some more, and doing some more, and doing some more. 
Then I'll hit Control C, 
it has a little counter in here that basically, 
if it hits 200 it stops, and you have to restart it. 
You could actually change this code, 
you can make it so it didn't sleep. 
Doesn't hurt to sleep for like a second after every 100 or so if you want. 
You can change that code. 
Now let's just hit Control C and blow it up. 
LS minus L. There is another bit of code, 
and this code it's always good to write these really simple things. 
Now we're going to now import Sqllite and json. 
We're going to connect ourselves up. 
We're going to open, 
except this is a UTF eight. 
Because it's a UTF, 
we're going to open this with UTF eight and we're going to read through. 
In this case, we're going to decode. 
You just select start from locations, and if you recall, 
locations has a location and a Geodata. 
So the sub zero will be the location and the sub one will be 
the the geodata and we're going to parse it. 
Convert it to a string and then parse it. 
If something goes wrong with json we'll just keep skipping it, 
or check to see if we have the status in our json. 
Let me run the Sqllite browser here.
Play video starting at :9:15 and follow transcript9:15
File, open database. 
Let's take a look at what's in this database. 
Where we code three geodata to data SqlLite. 
So this is our data, 
we've got so if you, 
I'll make this a little bigger if I can't, can I make that bigger? 
Yes, I can show us much. 
So you can see that these are the addresses and geodata that's just json. 
So that's the json that we've got and it retrieves it. 
So this is a really simple database, 
there's just sort of spidering process run run run. 
But now we're going to run the geodump code, 
which is going to read this and dump this stuff out, 
and print where.js, so it's going to actually parse this stuff. 
That's code we've seen before. 
So we're actually reading it and this line goes into the results. 
Results is an array so if we go into results, 
results in an array. 
We're going to go grab the zero item in that array, 
then we're going to go find a geometry, 
and then location, and then lat and long for the latitude and longitude. 
Then we're also going to take the actual address out of the formatted address right here. 
So, in this bit of code, 
we're actually parsing the json and we're going to clean things up, 
get rid of some single quotes. 
This kind of data cleaning is just stuff after you play with it for awhile, 
you realize oh my data's ugly, or does this. 
Now print it out, then I'm going to write this out. 
I'm going to write it into a JavaScript file. 
So the Javascript file is this where.js. 
I'll show you what it looks like, 
it was going to be overwritten. 
This is the one that came out of the zip file. 
It'll have the latitude, the longitude, 
and we're going to use JavaScript to read this. 
In this where.html file, 
it's going to actually read this right there, 
and pull that data in. 
That's how we're going to visualize. 
I'm not going to go into great detail on how the visualization happens, 
but that's what's happening. 
So we're going to write that, we're going to actually write this to a file. 
Let's go ahead and run this code, 
and say Python three, geodump.
Play video starting at :11:34 and follow transcript11:34
Okay. So it wrote a 120 records to where.js. 
So if we look at where.js, 
this is now the new data that I just downloaded moments ago. 
It says open where.html in a browser.
Play video starting at :11:56 and follow transcript11:56
Now this you'll need the Google Maps API, 
and you might not be able to see this, 
depending on where you're at. 
But, here you go with the Google Maps locations. 
I think if you hover over this, you can see. 
You see the UTF why we're there in that particular thing, 
why we had to use the UTF eight when we wrote the file. 
So that we didn't end up with trouble writing the file out. 
There you go and so that is a simple visualization. 
Just a simple visualization and wrote this where.js. 
If you are smart with HTML and JavaScript, 
you can look at this where.HTML file, 
it's really just reading through a bunch of data and putting the points. 
That's all there is, 
but I'm not going to go through that, 
at least not in this. 
I hope this was useful to you and thanks for watching.

#### Peer Graded Assignment - Instructor Input
To get a grade for peer-graded assignments in this course, you must submit your assignment, then peer grade several other student submissions and then the course teaching staff will review your assignment and complete the grading of your assignment. It may take several days for the teaching staff to grade your assignment so that you receive full credit.
The instructor graded portion of the assignment is 3/10 points of the grade on the peer graded assignment (i.e. 30% of your grade). Since you must achieve 80% to complete the assignment within Coursera, you assignment will have a maximum of 70% and won’t be marked “complete” until the teaching staff completes their grading.
The teaching staff will review the comments from your peers and review your submission before awarding a grade. If you have made a mistake in your submission, the teaching staff can send you a note and reset your assignment to allow for resubmission.
If the teaching staff detects a violation of the Coursera Honor code that says that you can only submit your own work, it may result in permanent failure of this course or deactivation of your Coursera account according to the rules of the Coursera honor code.
If you have questions or concerns about the grading of these assignments, please let us know in the discussion forums.
Databases and Visualization (peer-graded)
In this assignment you will use the Google GeoCoding API to retrieve data and then use Google Maps to visualize the data.
________________________________________
This course uses a third-party app, Databases and Visualization (peer-graded), to enhance your learning experience. The app will reference basic information like your name, email, and Coursera ID.
Coursera Honor Code  Learn more
 
I, elham fazel, understand that submitting work that isn’t my own may result in permanent failure of this course or deactivation of my Coursera account.

[MUSIC] 
Hello everybody. 
Chuck here. 
We're in Amsterdam. 
This is the second office hours that have happened in Amsterdam. 
And we had a great turnout tonight. 
And I want to introduce you to your fellow students and 
let them talk a little bit about the class. 
So, give us your name and tell us a little bit about the class, 
what's your interested in, what you think you're getting out of it. 
>> Hi my name is. 
I like computer science. 
I also like art in general.
Play video starting at ::30 and follow transcript0:30
It was a great course, did a great job and it was very nice. 
That's it. 
>> Okay. >> Hi I'm Arya and 
I'm a lecturer at the University of Applied Science and 
I'm teaching some about digital interactive media. 
So I want to know more about the beginnings of the Internet so that's why I 
took the course and it helped me build more knowledge about how it all began. 
>> So I'm really excited that you are applying some of it in your own course. 
>> Yes, and I'm also using the stuff I've learned and 
I'm using the peer grading system as well in one of my lectures just to try. 
>> Great, your turn. 
>> Hi, I'm Ben. 
I work here in Amsterdam. 
I'm a system administrator.
Play video starting at :1:18 and follow transcript1:18
I work with all these cool technologies, 
and I miss the feeling about where it all came from, and how it started. 
So this course really gives me that information, and 
it helps a lot to understand how things came to be. 
So, thanks Chuck. 
>> So how do you think the course can be improved? 
>> I think you need to put in something about the seven layer OC model, 
'cause it's lacking that. 
Other than that, keep on rolling. 
>> [LAUGH] >> Yeah, hi everyone. 
I'm Julianna from Brazil. 
I'm doing a master here in Amsterdam. 
It's unique and distant culture. 
So, well, I enrolled in this MOOC because I'm studying MOOCs. 
It's what I did for my master's thesis. 
And well it's a really great course. 
I expect I want to continue with the course because 
it is the first week, but okay. 
That's another story. 
It's really great, it's a great way, a fun way to learn about Internet. 
Not to read like a boring Wikipedia article. 
So yeah, I want to continue. 
>> Thank you. 
Now, you're the first person who's ever come to office hours before, 
you're registered for the next class right? 
>> Exactly. 
[LAUGH] >> So 
tell us a little bit about what you expect might come out of the course. 
>> Well I got extremely curious to hear about all what I've
Play video starting at :2:40 and follow transcript2:40
already heard from the former students. 
I wanna learn about from scratch about Internet, and look how it's functioning, 
where it's coming from, to understand it actually. 
Cuz I'm coming from the field of humanities and 
I don't know anything about it so. 
This is why I'm here, and thanks for being so enthusiastic actually, and teaching us. 
[LAUGH] Looking forward to it. 
>> And so there you have it. 
Yet another successful office hours around the world. 
It's the first time that I've done an office hours 
more than once in the same city. 
Cheers.

[MUSIC]
Play video starting at ::18 and follow transcript0:18
The Free Software Foundation's mission is to promote users' freedom to copy and 
redistribute and change software. 
Free software refers to freedom, not price, 
so the alternate to free software is proprietary software. 
Proprietary software that subjugates and divides the users, 
that's what's wrong about it is because it divides and subjugates people. 
It doesn't respect users' freedom, 
it doesn't allow users to be part of a community, and that's why it's wrong. 
It's not wrong for programmers to make money. 
And as long as they can make money in a way that respects the freedom of other 
people, I think that's good. 
After all, I'm a programmer and I'm not unhappy when I make some money, but 
I only do it in ways that respect the freedom of other people. 
Back in the 1980s, it was possible for people to speculate, 
speculatively assume that we couldn't possibly do such a big job 
because nobody would write the software if they weren't getting paid. 
Well, now we know from experience that lots of people will work on free software 
even if they don't get paid. 
And at the same time, 
a number of people have found ways to get paid to write free software. 
So, we've now shown that we can do very large jobs. 
We can produce a broad spectrum of software that is very high quality and 
that users like to use. 
Well, I think that the World Wide Web should eventually become 
the free encyclopedia of all knowledge. 
That it should have articles covering every topic that you'd want 
to have in an encyclopedia. 
And every one of these articles should be available for access at no charge, 
and people should be permitted to redistribute them also, and 
also to quote any part of the article in a new article. 
I think that they'll be written mostly by teachers, college teachers, 
high school teachers. 
If each one writes an article a year, not every teacher because obviously 
they won't all do this, but if a couple of thousand teachers get involved and 
each one writes an article per year, that's not a very large part of your time, 
and that'll get the job done in a decade or two. 
[MUSIC]

We got our start in the early days of the web as a group of disaffected webmasters 
who were using a piece of freely available web software. 
But I had difficulty with it. 
We were fixing bugs, we were sharing these big fixes 
with each other like baseball trading cards, if you will. 
These patches, as it's called. 
And one day we discovered the group that put out the web server that we were using 
basically folded when all their developers left to go 
join a brand new company called Netscape. 
So a bunch of us decided that hey, we're dependent upon this software. 
We don't want to become full-time web server developers, 
but we want to be able to use this thing that we've had for free, 
and be able to improve it, and all that kind of stuff. 
We looked at the license of the code. 
And the license said, here's this software, do whatever you want with it. 
Don't blame us when it breaks. 
Right? 
And we said, hey that's a pretty good bargain. 
Why don't we pass the same bargain onto the next group of people? 
Right? 
So, we formed a mailing list. 
Right? And this was mostly, again, webmasters, 
and people working at some early Internet service providers or 
website design companies or places like Amazon or the Internet Movie Database. 
And we combined our patches together and 
decided to call it Apache Server for that reason, and it went forward. 
And really the model of how we worked was based upon us as a group, as peers. 
Proposing ideas, vetting each other's ideas and patches, and 
fixing bugs as a group, as a team. 
None of us had met in person, well some of us have met, but as a group we didn't 
meet in person until 1998, really three years after we got our start. 
And long after, by the way, 
we had become the most predominant web server product on the planet. 
And yet at this time still no money, no dime. 
Not direct to us from this piece of open source software, but 
plenty of us made our living off of building things on top of this piece. 
And that's really the story, I think, of successful open source projects writ large. 
Which is people working together on common technologies to solve common problems, 
so they can go off and make money on other places. 
Or so they can have fun, they can try new ideas, they can be experimental. 
Right? 
And that's really the same story of Apache and of Linux and 
all these other open source projects. 
It turns out to be not that hard to be able to work together when 
people have the same common goal, 
which is let's build a product that does all of this great stuff. 
One thing that we did do that made it easy to make some of these decisions was to 
have a very modular API. 
Which made it easy for us to be able to say, 
hey, if you want that special cool feature, do it as a separate thing 
and make it successful and we'll decide whether to bring this into the product 
once it's become successful or not. 
Right? 
Another key thing that plays into this that is true to all open source projects 
is that an open source license like we had on ours, that Linux has, 
et cetera, carries with it something called the right to fork. 
Which means that if I were to go all Colonel Kurtz on the project and 
start saying we're going to go here and no one else wanted to follow. 
Well, all of those other people could decide to pick up the code and 
go start a different project somewhere else. 
If they couldn't kick me out, 
which is probably what they would have tried to do first. 
Right? 
This right to fork means that you don't have to have any tolerance for dictators. 
You don't have to deal with people who make bad technical decisions.
Play video starting at :3:43 and follow transcript3:43
You can take that future into your hands and if you find a group of other people 
who agree with you, you can go on and create a new project around it. 
So I think that rule, that right to fork, limits the kind of excesses that we 
see whenever we start to talk about how do groups make decisions. 
And when conflict arises, how do you deal with that conflict? 
And it means that style of leadership isn't so much one of control and plotting 
moves ahead of time, but instead one of being able to get people on your side. 
Convince them that you're going to value their efforts, 
value the contributions that they make. 
[MUSIC]
Please Rate this Course on Class-Central
While this is not a requirement, we would appreciate it if you took a bit of time and rated this course on Class Central.
https://www.class-central.com/mooc/4272/coursera-using-databases-with-python
Class Central has become a registry that allows people to find free and open courses across multiple course providers. Class Central also publishes articles about what is happening in the Massively Open Online Course (MOOC) space.
‘Post-Course Survey
We are very interested in strengthening and improving our online learning experiences. We would love to get your feedback on this course to help us identify what we're doing right and what could use improvement. Please participate by taking our short survey at the link below:
Go to survey.
Thank you for participating!
Keep Learning with Michigan Online
 
Want to keep learning? Explore hundreds of learning experiences from the University of Michigan faculty and instructional teams on Michigan Online.
Be the first to know about new learning experiences from the University of Michigan! Subscribe to the Michigan Online email list! 
Summarize:
The attached document titled "Using Databases with Python.docx" provides information about a course on databases using Python. The course covers various topics such as object-oriented programming, structured query language (SQL), and data visualization. It emphasizes the importance of understanding databases for Python programming. The document also includes details about the course syllabus, participation strategies, grading policy, ground rules for discussions, and academic honesty. Additionally, it mentions a survey for gathering information about the participants and provides resources for obtaining the Python textbook and course materials.
